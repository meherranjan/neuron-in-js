'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _rollupPluginBabelHelpers = require('../../../../_virtual/_rollupPluginBabelHelpers.js');
var reactSpringShared_esm = require('../../shared/dist/react-spring-shared.esm.js');
var React = require('react');
var reactSpringRafz_esm = require('../../rafz/dist/react-spring-rafz.esm.js');

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var React__namespace = /*#__PURE__*/_interopNamespace(React);

var $node = Symbol["for"]('Animated:node');

var isAnimated = function isAnimated(value) {
  return !!value && value[$node] === value;
};

var getAnimated = function getAnimated(owner) {
  return owner && owner[$node];
};

var setAnimated = function setAnimated(owner, node) {
  return reactSpringShared_esm.defineHidden(owner, $node, node);
};

var getPayload = function getPayload(owner) {
  return owner && owner[$node] && owner[$node].getPayload();
};

var Animated = /*#__PURE__*/function () {
  function Animated() {
    _rollupPluginBabelHelpers.classCallCheck(this, Animated);

    this.payload = void 0;
    setAnimated(this, this);
  }

  _rollupPluginBabelHelpers.createClass(Animated, [{
    key: "getPayload",
    value: function getPayload() {
      return this.payload || [];
    }
  }]);

  return Animated;
}();

var AnimatedValue = /*#__PURE__*/function (_Animated) {
  _rollupPluginBabelHelpers.inherits(AnimatedValue, _Animated);

  var _super = _rollupPluginBabelHelpers.createSuper(AnimatedValue);

  function AnimatedValue(_value) {
    var _this;

    _rollupPluginBabelHelpers.classCallCheck(this, AnimatedValue);

    _this = _super.call(this);
    _this.done = true;
    _this.elapsedTime = void 0;
    _this.lastPosition = void 0;
    _this.lastVelocity = void 0;
    _this.v0 = void 0;
    _this.durationProgress = 0;
    _this._value = _value;

    if (reactSpringShared_esm.is.num(_this._value)) {
      _this.lastPosition = _this._value;
    }

    return _this;
  }

  _rollupPluginBabelHelpers.createClass(AnimatedValue, [{
    key: "getPayload",
    value: function getPayload() {
      return [this];
    }
  }, {
    key: "getValue",
    value: function getValue() {
      return this._value;
    }
  }, {
    key: "setValue",
    value: function setValue(value, step) {
      if (reactSpringShared_esm.is.num(value)) {
        this.lastPosition = value;

        if (step) {
          value = Math.round(value / step) * step;

          if (this.done) {
            this.lastPosition = value;
          }
        }
      }

      if (this._value === value) {
        return false;
      }

      this._value = value;
      return true;
    }
  }, {
    key: "reset",
    value: function reset() {
      var done = this.done;
      this.done = false;

      if (reactSpringShared_esm.is.num(this._value)) {
        this.elapsedTime = 0;
        this.durationProgress = 0;
        this.lastPosition = this._value;
        if (done) this.lastVelocity = null;
        this.v0 = null;
      }
    }
  }], [{
    key: "create",
    value: function create(value) {
      return new AnimatedValue(value);
    }
  }]);

  return AnimatedValue;
}(Animated);

var AnimatedString = /*#__PURE__*/function (_AnimatedValue) {
  _rollupPluginBabelHelpers.inherits(AnimatedString, _AnimatedValue);

  var _super2 = _rollupPluginBabelHelpers.createSuper(AnimatedString);

  function AnimatedString(value) {
    var _this2;

    _rollupPluginBabelHelpers.classCallCheck(this, AnimatedString);

    _this2 = _super2.call(this, 0);
    _this2._string = null;
    _this2._toString = void 0;
    _this2._toString = reactSpringShared_esm.createInterpolator({
      output: [value, value]
    });
    return _this2;
  }

  _rollupPluginBabelHelpers.createClass(AnimatedString, [{
    key: "getValue",
    value: function getValue() {
      var value = this._string;
      return value == null ? this._string = this._toString(this._value) : value;
    }
  }, {
    key: "setValue",
    value: function setValue(value) {
      if (reactSpringShared_esm.is.str(value)) {
        if (value == this._string) {
          return false;
        }

        this._string = value;
        this._value = 1;
      } else if (_rollupPluginBabelHelpers.get(_rollupPluginBabelHelpers.getPrototypeOf(AnimatedString.prototype), "setValue", this).call(this, value)) {
        this._string = null;
      } else {
        return false;
      }

      return true;
    }
  }, {
    key: "reset",
    value: function reset(goal) {
      if (goal) {
        this._toString = reactSpringShared_esm.createInterpolator({
          output: [this.getValue(), goal]
        });
      }

      this._value = 0;

      _rollupPluginBabelHelpers.get(_rollupPluginBabelHelpers.getPrototypeOf(AnimatedString.prototype), "reset", this).call(this);
    }
  }], [{
    key: "create",
    value: function create(value) {
      return new AnimatedString(value);
    }
  }]);

  return AnimatedString;
}(AnimatedValue);

var TreeContext = {
  dependencies: null
};

var AnimatedObject = /*#__PURE__*/function (_Animated2) {
  _rollupPluginBabelHelpers.inherits(AnimatedObject, _Animated2);

  var _super3 = _rollupPluginBabelHelpers.createSuper(AnimatedObject);

  function AnimatedObject(source) {
    var _this3;

    _rollupPluginBabelHelpers.classCallCheck(this, AnimatedObject);

    _this3 = _super3.call(this);
    _this3.source = source;

    _this3.setValue(source);

    return _this3;
  }

  _rollupPluginBabelHelpers.createClass(AnimatedObject, [{
    key: "getValue",
    value: function getValue(animated) {
      var values = {};
      reactSpringShared_esm.eachProp(this.source, function (source, key) {
        if (isAnimated(source)) {
          values[key] = source.getValue(animated);
        } else if (reactSpringShared_esm.hasFluidValue(source)) {
          values[key] = reactSpringShared_esm.getFluidValue(source);
        } else if (!animated) {
          values[key] = source;
        }
      });
      return values;
    }
  }, {
    key: "setValue",
    value: function setValue(source) {
      this.source = source;
      this.payload = this._makePayload(source);
    }
  }, {
    key: "reset",
    value: function reset() {
      if (this.payload) {
        reactSpringShared_esm.each(this.payload, function (node) {
          return node.reset();
        });
      }
    }
  }, {
    key: "_makePayload",
    value: function _makePayload(source) {
      if (source) {
        var payload = new Set();
        reactSpringShared_esm.eachProp(source, this._addToPayload, payload);
        return Array.from(payload);
      }
    }
  }, {
    key: "_addToPayload",
    value: function _addToPayload(source) {
      var _this4 = this;

      if (TreeContext.dependencies && reactSpringShared_esm.hasFluidValue(source)) {
        TreeContext.dependencies.add(source);
      }

      var payload = getPayload(source);

      if (payload) {
        reactSpringShared_esm.each(payload, function (node) {
          return _this4.add(node);
        });
      }
    }
  }]);

  return AnimatedObject;
}(Animated);

var AnimatedArray = /*#__PURE__*/function (_AnimatedObject) {
  _rollupPluginBabelHelpers.inherits(AnimatedArray, _AnimatedObject);

  var _super4 = _rollupPluginBabelHelpers.createSuper(AnimatedArray);

  function AnimatedArray(source) {
    _rollupPluginBabelHelpers.classCallCheck(this, AnimatedArray);

    return _super4.call(this, source);
  }

  _rollupPluginBabelHelpers.createClass(AnimatedArray, [{
    key: "getValue",
    value: function getValue() {
      return this.source.map(function (node) {
        return node.getValue();
      });
    }
  }, {
    key: "setValue",
    value: function setValue(source) {
      var payload = this.getPayload();

      if (source.length == payload.length) {
        return payload.map(function (node, i) {
          return node.setValue(source[i]);
        }).some(Boolean);
      }

      _rollupPluginBabelHelpers.get(_rollupPluginBabelHelpers.getPrototypeOf(AnimatedArray.prototype), "setValue", this).call(this, source.map(makeAnimated));

      return true;
    }
  }], [{
    key: "create",
    value: function create(source) {
      return new AnimatedArray(source);
    }
  }]);

  return AnimatedArray;
}(AnimatedObject);

function makeAnimated(value) {
  var nodeType = reactSpringShared_esm.isAnimatedString(value) ? AnimatedString : AnimatedValue;
  return nodeType.create(value);
}

function getAnimatedType(value) {
  var parentNode = getAnimated(value);
  return parentNode ? parentNode.constructor : reactSpringShared_esm.is.arr(value) ? AnimatedArray : reactSpringShared_esm.isAnimatedString(value) ? AnimatedString : AnimatedValue;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

var withAnimated = function withAnimated(Component, host) {
  var hasInstance = !reactSpringShared_esm.is.fun(Component) || Component.prototype && Component.prototype.isReactComponent;
  return /*#__PURE__*/React.forwardRef(function (givenProps, givenRef) {
    var instanceRef = React.useRef(null);
    var ref = hasInstance && React.useCallback(function (value) {
      instanceRef.current = updateRef(givenRef, value);
    }, [givenRef]);

    var _getAnimatedState = getAnimatedState(givenProps, host),
        _getAnimatedState2 = _rollupPluginBabelHelpers.slicedToArray(_getAnimatedState, 2),
        props = _getAnimatedState2[0],
        deps = _getAnimatedState2[1];

    var forceUpdate = reactSpringShared_esm.useForceUpdate();

    var callback = function callback() {
      var instance = instanceRef.current;

      if (hasInstance && !instance) {
        return;
      }

      var didUpdate = instance ? host.applyAnimatedValues(instance, props.getValue(true)) : false;

      if (didUpdate === false) {
        forceUpdate();
      }
    };

    var observer = new PropsObserver(callback, deps);
    var observerRef = React.useRef();
    reactSpringShared_esm.useLayoutEffect(function () {
      observerRef.current = observer;
      reactSpringShared_esm.each(deps, function (dep) {
        return reactSpringShared_esm.addFluidObserver(dep, observer);
      });
      return function () {
        if (observerRef.current) {
          reactSpringShared_esm.each(observerRef.current.deps, function (dep) {
            return reactSpringShared_esm.removeFluidObserver(dep, observerRef.current);
          });
          reactSpringRafz_esm.raf.cancel(observerRef.current.update);
        }
      };
    });
    React.useEffect(callback, []);
    reactSpringShared_esm.useOnce(function () {
      return function () {
        var observer = observerRef.current;
        reactSpringShared_esm.each(observer.deps, function (dep) {
          return reactSpringShared_esm.removeFluidObserver(dep, observer);
        });
      };
    });
    var usedProps = host.getComponentProps(props.getValue());
    return /*#__PURE__*/React__namespace.createElement(Component, _extends({}, usedProps, {
      ref: ref
    }));
  });
};

var PropsObserver = /*#__PURE__*/function () {
  function PropsObserver(update, deps) {
    _rollupPluginBabelHelpers.classCallCheck(this, PropsObserver);

    this.update = update;
    this.deps = deps;
  }

  _rollupPluginBabelHelpers.createClass(PropsObserver, [{
    key: "eventObserved",
    value: function eventObserved(event) {
      if (event.type == 'change') {
        reactSpringRafz_esm.raf.write(this.update);
      }
    }
  }]);

  return PropsObserver;
}();

function getAnimatedState(props, host) {
  var dependencies = new Set();
  TreeContext.dependencies = dependencies;
  if (props.style) props = _extends({}, props, {
    style: host.createAnimatedStyle(props.style)
  });
  props = new AnimatedObject(props);
  TreeContext.dependencies = null;
  return [props, dependencies];
}

function updateRef(ref, value) {
  if (ref) {
    if (reactSpringShared_esm.is.fun(ref)) ref(value);else ref.current = value;
  }

  return value;
}

var cacheKey = Symbol["for"]('AnimatedComponent');

var createHost = function createHost(components) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$applyAnimatedVal = _ref.applyAnimatedValues,
      _applyAnimatedValues = _ref$applyAnimatedVal === void 0 ? function () {
    return false;
  } : _ref$applyAnimatedVal,
      _ref$createAnimatedSt = _ref.createAnimatedStyle,
      _createAnimatedStyle = _ref$createAnimatedSt === void 0 ? function (style) {
    return new AnimatedObject(style);
  } : _ref$createAnimatedSt,
      _ref$getComponentProp = _ref.getComponentProps,
      _getComponentProps = _ref$getComponentProp === void 0 ? function (props) {
    return props;
  } : _ref$getComponentProp;

  var hostConfig = {
    applyAnimatedValues: _applyAnimatedValues,
    createAnimatedStyle: _createAnimatedStyle,
    getComponentProps: _getComponentProps
  };

  var animated = function animated(Component) {
    var displayName = getDisplayName(Component) || 'Anonymous';

    if (reactSpringShared_esm.is.str(Component)) {
      Component = animated[Component] || (animated[Component] = withAnimated(Component, hostConfig));
    } else {
      Component = Component[cacheKey] || (Component[cacheKey] = withAnimated(Component, hostConfig));
    }

    Component.displayName = "Animated(".concat(displayName, ")");
    return Component;
  };

  reactSpringShared_esm.eachProp(components, function (Component, key) {
    if (reactSpringShared_esm.is.arr(components)) {
      key = getDisplayName(Component);
    }

    animated[key] = animated(Component);
  });
  return {
    animated: animated
  };
};

var getDisplayName = function getDisplayName(arg) {
  return reactSpringShared_esm.is.str(arg) ? arg : arg && reactSpringShared_esm.is.str(arg.displayName) ? arg.displayName : reactSpringShared_esm.is.fun(arg) && arg.name || null;
};

exports.Animated = Animated;
exports.AnimatedArray = AnimatedArray;
exports.AnimatedObject = AnimatedObject;
exports.AnimatedString = AnimatedString;
exports.AnimatedValue = AnimatedValue;
exports.createHost = createHost;
exports.getAnimated = getAnimated;
exports.getAnimatedType = getAnimatedType;
exports.getPayload = getPayload;
exports.isAnimated = isAnimated;
exports.setAnimated = setAnimated;
//# sourceMappingURL=react-spring-animated.esm.js.map
