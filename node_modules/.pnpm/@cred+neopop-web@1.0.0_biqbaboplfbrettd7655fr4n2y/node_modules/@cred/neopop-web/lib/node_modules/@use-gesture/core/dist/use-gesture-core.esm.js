'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _rollupPluginBabelHelpers = require('../../../../_virtual/_rollupPluginBabelHelpers.js');
var actions1416bf77_esm = require('./actions-1416bf77.esm.js');

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

var sharedConfigResolver = {
  target: function target(value) {
    if (value) {
      return function () {
        return 'current' in value ? value.current : value;
      };
    }

    return undefined;
  },
  enabled: function enabled() {
    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
    return value;
  },
  window: function (_window) {
    function window() {
      return _window.apply(this, arguments);
    }

    window.toString = function () {
      return _window.toString();
    };

    return window;
  }(function () {
    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : actions1416bf77_esm.S.isBrowser ? window : undefined;
    return value;
  }),
  eventOptions: function eventOptions() {
    var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref2$passive = _ref2.passive,
        passive = _ref2$passive === void 0 ? true : _ref2$passive,
        _ref2$capture = _ref2.capture,
        capture = _ref2$capture === void 0 ? false : _ref2$capture;

    return {
      passive: passive,
      capture: capture
    };
  },
  transform: function transform(value) {
    return value;
  }
};
var _excluded = ["target", "eventOptions", "window", "enabled", "transform"];

function resolveWith() {
  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var resolvers = arguments.length > 1 ? arguments[1] : undefined;
  var result = {};

  for (var _i = 0, _Object$entries = Object.entries(resolvers); _i < _Object$entries.length; _i++) {
    var _Object$entries$_i = _rollupPluginBabelHelpers.slicedToArray(_Object$entries[_i], 2),
        key = _Object$entries$_i[0],
        resolver = _Object$entries$_i[1];

    switch (_rollupPluginBabelHelpers["typeof"](resolver)) {
      case 'function':
        if (process.env.NODE_ENV === 'development') {
          var r = resolver.call(result, config[key], key, config);
          if (!Number.isNaN(r)) result[key] = r;
        } else {
          result[key] = resolver.call(result, config[key], key, config);
        }

        break;

      case 'object':
        result[key] = resolveWith(config[key], resolver);
        break;

      case 'boolean':
        if (resolver) result[key] = config[key];
        break;
    }
  }

  return result;
}

function parse(config, gestureKey) {
  var _ref = config,
      target = _ref.target,
      eventOptions = _ref.eventOptions,
      window = _ref.window,
      enabled = _ref.enabled,
      transform = _ref.transform,
      rest = _objectWithoutProperties(_ref, _excluded);

  var _config = {
    shared: resolveWith({
      target: target,
      eventOptions: eventOptions,
      window: window,
      enabled: enabled,
      transform: transform
    }, sharedConfigResolver)
  };

  if (gestureKey) {
    var resolver = actions1416bf77_esm.C.get(gestureKey);
    _config[gestureKey] = resolveWith(actions1416bf77_esm._({
      shared: _config.shared
    }, rest), resolver);
  } else {
    for (var key in rest) {
      var _resolver = actions1416bf77_esm.C.get(key);

      if (_resolver) {
        _config[key] = resolveWith(actions1416bf77_esm._({
          shared: _config.shared
        }, rest[key]), _resolver);
      } else if (process.env.NODE_ENV === 'development') {
        if (!['drag', 'pinch', 'scroll', 'wheel', 'move', 'hover'].includes(key)) {
          if (key === 'domTarget') {
            throw Error("[@use-gesture]: `domTarget` option has been renamed to `target`.");
          }

          console.warn("[@use-gesture]: Unknown config key `".concat(key, "` was used. Please read the documentation for further information."));
        }
      }
    }
  }

  return _config;
}

var EventStore = /*#__PURE__*/function () {
  function EventStore(ctrl, gestureKey) {
    _rollupPluginBabelHelpers.classCallCheck(this, EventStore);

    actions1416bf77_esm.a(this, "_listeners", new Set());

    this._ctrl = ctrl;
    this._gestureKey = gestureKey;
  }

  _rollupPluginBabelHelpers.createClass(EventStore, [{
    key: "add",
    value: function add(element, device, action, handler, options) {
      var listeners = this._listeners;
      var type = actions1416bf77_esm.t(device, action);

      var _options = this._gestureKey ? this._ctrl.config[this._gestureKey].eventOptions : {};

      var eventOptions = actions1416bf77_esm._(actions1416bf77_esm._({}, _options), options);

      element.addEventListener(type, handler, eventOptions);

      var remove = function remove() {
        element.removeEventListener(type, handler, eventOptions);
        listeners["delete"](remove);
      };

      listeners.add(remove);
      return remove;
    }
  }, {
    key: "clean",
    value: function clean() {
      this._listeners.forEach(function (remove) {
        return remove();
      });

      this._listeners.clear();
    }
  }]);

  return EventStore;
}();

var TimeoutStore = /*#__PURE__*/function () {
  function TimeoutStore() {
    _rollupPluginBabelHelpers.classCallCheck(this, TimeoutStore);

    actions1416bf77_esm.a(this, "_timeouts", new Map());
  }

  _rollupPluginBabelHelpers.createClass(TimeoutStore, [{
    key: "add",
    value: function add(key, callback) {
      var _window2;

      var ms = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 140;
      this.remove(key);

      for (var _len = arguments.length, args = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
        args[_key - 3] = arguments[_key];
      }

      this._timeouts.set(key, (_window2 = window).setTimeout.apply(_window2, [callback, ms].concat(args)));
    }
  }, {
    key: "remove",
    value: function remove(key) {
      var timeout = this._timeouts.get(key);

      if (timeout) window.clearTimeout(timeout);
    }
  }, {
    key: "clean",
    value: function clean() {
      this._timeouts.forEach(function (timeout) {
        return void window.clearTimeout(timeout);
      });

      this._timeouts.clear();
    }
  }]);

  return TimeoutStore;
}();

var Controller = /*#__PURE__*/function () {
  function Controller(handlers) {
    _rollupPluginBabelHelpers.classCallCheck(this, Controller);

    actions1416bf77_esm.a(this, "gestures", new Set());

    actions1416bf77_esm.a(this, "_targetEventStore", new EventStore(this));

    actions1416bf77_esm.a(this, "gestureEventStores", {});

    actions1416bf77_esm.a(this, "gestureTimeoutStores", {});

    actions1416bf77_esm.a(this, "handlers", {});

    actions1416bf77_esm.a(this, "config", {});

    actions1416bf77_esm.a(this, "pointerIds", new Set());

    actions1416bf77_esm.a(this, "touchIds", new Set());

    actions1416bf77_esm.a(this, "state", {
      shared: {
        shiftKey: false,
        metaKey: false,
        ctrlKey: false,
        altKey: false
      }
    });

    resolveGestures(this, handlers);
  }

  _rollupPluginBabelHelpers.createClass(Controller, [{
    key: "setEventIds",
    value: function setEventIds(event) {
      if (actions1416bf77_esm.i(event)) {
        this.touchIds = new Set(actions1416bf77_esm.b(event));
        return this.touchIds;
      } else if ('pointerId' in event) {
        if (event.type === 'pointerup' || event.type === 'pointercancel') this.pointerIds["delete"](event.pointerId);else if (event.type === 'pointerdown') this.pointerIds.add(event.pointerId);
        return this.pointerIds;
      }
    }
  }, {
    key: "applyHandlers",
    value: function applyHandlers(handlers, nativeHandlers) {
      this.handlers = handlers;
      this.nativeHandlers = nativeHandlers;
    }
  }, {
    key: "applyConfig",
    value: function applyConfig(config, gestureKey) {
      this.config = parse(config, gestureKey);
    }
  }, {
    key: "clean",
    value: function clean() {
      this._targetEventStore.clean();

      var _iterator = _rollupPluginBabelHelpers.createForOfIteratorHelper(this.gestures),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var key = _step.value;
          this.gestureEventStores[key].clean();
          this.gestureTimeoutStores[key].clean();
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
  }, {
    key: "effect",
    value: function effect() {
      var _this = this;

      if (this.config.shared.target) this.bind();
      return function () {
        return _this._targetEventStore.clean();
      };
    }
  }, {
    key: "bind",
    value: function bind() {
      var _this2 = this;

      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      var sharedConfig = this.config.shared;
      var props = {};
      var target;

      if (sharedConfig.target) {
        target = sharedConfig.target();
        if (!target) return;
      }

      if (sharedConfig.enabled) {
        var _iterator2 = _rollupPluginBabelHelpers.createForOfIteratorHelper(this.gestures),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var gestureKey = _step2.value;
            var gestureConfig = this.config[gestureKey];
            var bindFunction = bindToProps(props, gestureConfig.eventOptions, !!target);

            if (gestureConfig.enabled) {
              var Engine = actions1416bf77_esm.E.get(gestureKey);
              new Engine(this, args, gestureKey).bind(bindFunction);
            }
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }

        var nativeBindFunction = bindToProps(props, sharedConfig.eventOptions, !!target);

        var _loop = function _loop(eventKey) {
          nativeBindFunction(eventKey, '', function (event) {
            return _this2.nativeHandlers[eventKey](actions1416bf77_esm._(actions1416bf77_esm._({}, _this2.state.shared), {}, {
              event: event,
              args: args
            }));
          }, undefined, true);
        };

        for (var eventKey in this.nativeHandlers) {
          _loop(eventKey);
        }
      }

      for (var handlerProp in props) {
        props[handlerProp] = actions1416bf77_esm.c.apply(void 0, _rollupPluginBabelHelpers.toConsumableArray(props[handlerProp]));
      }

      if (!target) return props;

      for (var _handlerProp in props) {
        var _parseProp = actions1416bf77_esm.p(_handlerProp),
            device = _parseProp.device,
            capture = _parseProp.capture,
            passive = _parseProp.passive;

        this._targetEventStore.add(target, device, '', props[_handlerProp], {
          capture: capture,
          passive: passive
        });
      }
    }
  }]);

  return Controller;
}();

function setupGesture(ctrl, gestureKey) {
  ctrl.gestures.add(gestureKey);
  ctrl.gestureEventStores[gestureKey] = new EventStore(ctrl, gestureKey);
  ctrl.gestureTimeoutStores[gestureKey] = new TimeoutStore();
}

function resolveGestures(ctrl, internalHandlers) {
  if (internalHandlers.drag) setupGesture(ctrl, 'drag');
  if (internalHandlers.wheel) setupGesture(ctrl, 'wheel');
  if (internalHandlers.scroll) setupGesture(ctrl, 'scroll');
  if (internalHandlers.move) setupGesture(ctrl, 'move');
  if (internalHandlers.pinch) setupGesture(ctrl, 'pinch');
  if (internalHandlers.hover) setupGesture(ctrl, 'hover');
}

var bindToProps = function bindToProps(props, eventOptions, withPassiveOption) {
  return function (device, action, handler) {
    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    var isNative = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

    var _options$capture, _options$passive;

    var capture = (_options$capture = options.capture) !== null && _options$capture !== void 0 ? _options$capture : eventOptions.capture;
    var passive = (_options$passive = options.passive) !== null && _options$passive !== void 0 ? _options$passive : eventOptions.passive;
    var handlerProp = isNative ? device : actions1416bf77_esm.d(device, action, capture);
    if (withPassiveOption && passive) handlerProp += 'Passive';
    props[handlerProp] = props[handlerProp] || [];
    props[handlerProp].push(handler);
  };
};

exports.Controller = Controller;
//# sourceMappingURL=use-gesture-core.esm.js.map
