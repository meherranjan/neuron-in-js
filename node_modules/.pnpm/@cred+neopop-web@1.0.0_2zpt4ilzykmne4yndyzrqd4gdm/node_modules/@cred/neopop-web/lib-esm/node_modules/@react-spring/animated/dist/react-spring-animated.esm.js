import { slicedToArray as _slicedToArray, createClass as _createClass, inherits as _inherits, createSuper as _createSuper, classCallCheck as _classCallCheck, get as _get, getPrototypeOf as _getPrototypeOf } from '../../../../_virtual/_rollupPluginBabelHelpers.js';
import { is, useForceUpdate, useLayoutEffect, each, removeFluidObserver, addFluidObserver, useOnce, eachProp, isAnimatedString, defineHidden, createInterpolator, hasFluidValue, getFluidValue } from '../../shared/dist/react-spring-shared.esm.js';
import * as React from 'react';
import { forwardRef, useRef, useCallback, useEffect } from 'react';
import { raf } from '../../rafz/dist/react-spring-rafz.esm.js';

var $node = Symbol["for"]('Animated:node');

var isAnimated = function isAnimated(value) {
  return !!value && value[$node] === value;
};

var getAnimated = function getAnimated(owner) {
  return owner && owner[$node];
};

var setAnimated = function setAnimated(owner, node) {
  return defineHidden(owner, $node, node);
};

var getPayload = function getPayload(owner) {
  return owner && owner[$node] && owner[$node].getPayload();
};

var Animated = /*#__PURE__*/function () {
  function Animated() {
    _classCallCheck(this, Animated);

    this.payload = void 0;
    setAnimated(this, this);
  }

  _createClass(Animated, [{
    key: "getPayload",
    value: function getPayload() {
      return this.payload || [];
    }
  }]);

  return Animated;
}();

var AnimatedValue = /*#__PURE__*/function (_Animated) {
  _inherits(AnimatedValue, _Animated);

  var _super = _createSuper(AnimatedValue);

  function AnimatedValue(_value) {
    var _this;

    _classCallCheck(this, AnimatedValue);

    _this = _super.call(this);
    _this.done = true;
    _this.elapsedTime = void 0;
    _this.lastPosition = void 0;
    _this.lastVelocity = void 0;
    _this.v0 = void 0;
    _this.durationProgress = 0;
    _this._value = _value;

    if (is.num(_this._value)) {
      _this.lastPosition = _this._value;
    }

    return _this;
  }

  _createClass(AnimatedValue, [{
    key: "getPayload",
    value: function getPayload() {
      return [this];
    }
  }, {
    key: "getValue",
    value: function getValue() {
      return this._value;
    }
  }, {
    key: "setValue",
    value: function setValue(value, step) {
      if (is.num(value)) {
        this.lastPosition = value;

        if (step) {
          value = Math.round(value / step) * step;

          if (this.done) {
            this.lastPosition = value;
          }
        }
      }

      if (this._value === value) {
        return false;
      }

      this._value = value;
      return true;
    }
  }, {
    key: "reset",
    value: function reset() {
      var done = this.done;
      this.done = false;

      if (is.num(this._value)) {
        this.elapsedTime = 0;
        this.durationProgress = 0;
        this.lastPosition = this._value;
        if (done) this.lastVelocity = null;
        this.v0 = null;
      }
    }
  }], [{
    key: "create",
    value: function create(value) {
      return new AnimatedValue(value);
    }
  }]);

  return AnimatedValue;
}(Animated);

var AnimatedString = /*#__PURE__*/function (_AnimatedValue) {
  _inherits(AnimatedString, _AnimatedValue);

  var _super2 = _createSuper(AnimatedString);

  function AnimatedString(value) {
    var _this2;

    _classCallCheck(this, AnimatedString);

    _this2 = _super2.call(this, 0);
    _this2._string = null;
    _this2._toString = void 0;
    _this2._toString = createInterpolator({
      output: [value, value]
    });
    return _this2;
  }

  _createClass(AnimatedString, [{
    key: "getValue",
    value: function getValue() {
      var value = this._string;
      return value == null ? this._string = this._toString(this._value) : value;
    }
  }, {
    key: "setValue",
    value: function setValue(value) {
      if (is.str(value)) {
        if (value == this._string) {
          return false;
        }

        this._string = value;
        this._value = 1;
      } else if (_get(_getPrototypeOf(AnimatedString.prototype), "setValue", this).call(this, value)) {
        this._string = null;
      } else {
        return false;
      }

      return true;
    }
  }, {
    key: "reset",
    value: function reset(goal) {
      if (goal) {
        this._toString = createInterpolator({
          output: [this.getValue(), goal]
        });
      }

      this._value = 0;

      _get(_getPrototypeOf(AnimatedString.prototype), "reset", this).call(this);
    }
  }], [{
    key: "create",
    value: function create(value) {
      return new AnimatedString(value);
    }
  }]);

  return AnimatedString;
}(AnimatedValue);

var TreeContext = {
  dependencies: null
};

var AnimatedObject = /*#__PURE__*/function (_Animated2) {
  _inherits(AnimatedObject, _Animated2);

  var _super3 = _createSuper(AnimatedObject);

  function AnimatedObject(source) {
    var _this3;

    _classCallCheck(this, AnimatedObject);

    _this3 = _super3.call(this);
    _this3.source = source;

    _this3.setValue(source);

    return _this3;
  }

  _createClass(AnimatedObject, [{
    key: "getValue",
    value: function getValue(animated) {
      var values = {};
      eachProp(this.source, function (source, key) {
        if (isAnimated(source)) {
          values[key] = source.getValue(animated);
        } else if (hasFluidValue(source)) {
          values[key] = getFluidValue(source);
        } else if (!animated) {
          values[key] = source;
        }
      });
      return values;
    }
  }, {
    key: "setValue",
    value: function setValue(source) {
      this.source = source;
      this.payload = this._makePayload(source);
    }
  }, {
    key: "reset",
    value: function reset() {
      if (this.payload) {
        each(this.payload, function (node) {
          return node.reset();
        });
      }
    }
  }, {
    key: "_makePayload",
    value: function _makePayload(source) {
      if (source) {
        var payload = new Set();
        eachProp(source, this._addToPayload, payload);
        return Array.from(payload);
      }
    }
  }, {
    key: "_addToPayload",
    value: function _addToPayload(source) {
      var _this4 = this;

      if (TreeContext.dependencies && hasFluidValue(source)) {
        TreeContext.dependencies.add(source);
      }

      var payload = getPayload(source);

      if (payload) {
        each(payload, function (node) {
          return _this4.add(node);
        });
      }
    }
  }]);

  return AnimatedObject;
}(Animated);

var AnimatedArray = /*#__PURE__*/function (_AnimatedObject) {
  _inherits(AnimatedArray, _AnimatedObject);

  var _super4 = _createSuper(AnimatedArray);

  function AnimatedArray(source) {
    _classCallCheck(this, AnimatedArray);

    return _super4.call(this, source);
  }

  _createClass(AnimatedArray, [{
    key: "getValue",
    value: function getValue() {
      return this.source.map(function (node) {
        return node.getValue();
      });
    }
  }, {
    key: "setValue",
    value: function setValue(source) {
      var payload = this.getPayload();

      if (source.length == payload.length) {
        return payload.map(function (node, i) {
          return node.setValue(source[i]);
        }).some(Boolean);
      }

      _get(_getPrototypeOf(AnimatedArray.prototype), "setValue", this).call(this, source.map(makeAnimated));

      return true;
    }
  }], [{
    key: "create",
    value: function create(source) {
      return new AnimatedArray(source);
    }
  }]);

  return AnimatedArray;
}(AnimatedObject);

function makeAnimated(value) {
  var nodeType = isAnimatedString(value) ? AnimatedString : AnimatedValue;
  return nodeType.create(value);
}

function getAnimatedType(value) {
  var parentNode = getAnimated(value);
  return parentNode ? parentNode.constructor : is.arr(value) ? AnimatedArray : isAnimatedString(value) ? AnimatedString : AnimatedValue;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

var withAnimated = function withAnimated(Component, host) {
  var hasInstance = !is.fun(Component) || Component.prototype && Component.prototype.isReactComponent;
  return /*#__PURE__*/forwardRef(function (givenProps, givenRef) {
    var instanceRef = useRef(null);
    var ref = hasInstance && useCallback(function (value) {
      instanceRef.current = updateRef(givenRef, value);
    }, [givenRef]);

    var _getAnimatedState = getAnimatedState(givenProps, host),
        _getAnimatedState2 = _slicedToArray(_getAnimatedState, 2),
        props = _getAnimatedState2[0],
        deps = _getAnimatedState2[1];

    var forceUpdate = useForceUpdate();

    var callback = function callback() {
      var instance = instanceRef.current;

      if (hasInstance && !instance) {
        return;
      }

      var didUpdate = instance ? host.applyAnimatedValues(instance, props.getValue(true)) : false;

      if (didUpdate === false) {
        forceUpdate();
      }
    };

    var observer = new PropsObserver(callback, deps);
    var observerRef = useRef();
    useLayoutEffect(function () {
      observerRef.current = observer;
      each(deps, function (dep) {
        return addFluidObserver(dep, observer);
      });
      return function () {
        if (observerRef.current) {
          each(observerRef.current.deps, function (dep) {
            return removeFluidObserver(dep, observerRef.current);
          });
          raf.cancel(observerRef.current.update);
        }
      };
    });
    useEffect(callback, []);
    useOnce(function () {
      return function () {
        var observer = observerRef.current;
        each(observer.deps, function (dep) {
          return removeFluidObserver(dep, observer);
        });
      };
    });
    var usedProps = host.getComponentProps(props.getValue());
    return /*#__PURE__*/React.createElement(Component, _extends({}, usedProps, {
      ref: ref
    }));
  });
};

var PropsObserver = /*#__PURE__*/function () {
  function PropsObserver(update, deps) {
    _classCallCheck(this, PropsObserver);

    this.update = update;
    this.deps = deps;
  }

  _createClass(PropsObserver, [{
    key: "eventObserved",
    value: function eventObserved(event) {
      if (event.type == 'change') {
        raf.write(this.update);
      }
    }
  }]);

  return PropsObserver;
}();

function getAnimatedState(props, host) {
  var dependencies = new Set();
  TreeContext.dependencies = dependencies;
  if (props.style) props = _extends({}, props, {
    style: host.createAnimatedStyle(props.style)
  });
  props = new AnimatedObject(props);
  TreeContext.dependencies = null;
  return [props, dependencies];
}

function updateRef(ref, value) {
  if (ref) {
    if (is.fun(ref)) ref(value);else ref.current = value;
  }

  return value;
}

var cacheKey = Symbol["for"]('AnimatedComponent');

var createHost = function createHost(components) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$applyAnimatedVal = _ref.applyAnimatedValues,
      _applyAnimatedValues = _ref$applyAnimatedVal === void 0 ? function () {
    return false;
  } : _ref$applyAnimatedVal,
      _ref$createAnimatedSt = _ref.createAnimatedStyle,
      _createAnimatedStyle = _ref$createAnimatedSt === void 0 ? function (style) {
    return new AnimatedObject(style);
  } : _ref$createAnimatedSt,
      _ref$getComponentProp = _ref.getComponentProps,
      _getComponentProps = _ref$getComponentProp === void 0 ? function (props) {
    return props;
  } : _ref$getComponentProp;

  var hostConfig = {
    applyAnimatedValues: _applyAnimatedValues,
    createAnimatedStyle: _createAnimatedStyle,
    getComponentProps: _getComponentProps
  };

  var animated = function animated(Component) {
    var displayName = getDisplayName(Component) || 'Anonymous';

    if (is.str(Component)) {
      Component = animated[Component] || (animated[Component] = withAnimated(Component, hostConfig));
    } else {
      Component = Component[cacheKey] || (Component[cacheKey] = withAnimated(Component, hostConfig));
    }

    Component.displayName = "Animated(".concat(displayName, ")");
    return Component;
  };

  eachProp(components, function (Component, key) {
    if (is.arr(components)) {
      key = getDisplayName(Component);
    }

    animated[key] = animated(Component);
  });
  return {
    animated: animated
  };
};

var getDisplayName = function getDisplayName(arg) {
  return is.str(arg) ? arg : arg && is.str(arg.displayName) ? arg.displayName : is.fun(arg) && arg.name || null;
};

export { Animated, AnimatedArray, AnimatedObject, AnimatedString, AnimatedValue, createHost, getAnimated, getAnimatedType, getPayload, isAnimated, setAnimated };
//# sourceMappingURL=react-spring-animated.esm.js.map
