'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _rollupPluginBabelHelpers = require('../../../../_virtual/_rollupPluginBabelHelpers.js');
var reactSpringRafz_esm = require('../../rafz/dist/react-spring-rafz.esm.js');
var React = require('react');

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var React__namespace = /*#__PURE__*/_interopNamespace(React);

function noop() {}

var defineHidden = function defineHidden(obj, key, value) {
  return Object.defineProperty(obj, key, {
    value: value,
    writable: true,
    configurable: true
  });
};

var is = {
  arr: Array.isArray,
  obj: function obj(a) {
    return !!a && a.constructor.name === 'Object';
  },
  fun: function fun(a) {
    return typeof a === 'function';
  },
  str: function str(a) {
    return typeof a === 'string';
  },
  num: function num(a) {
    return typeof a === 'number';
  },
  und: function und(a) {
    return a === undefined;
  }
};

function isEqual(a, b) {
  if (is.arr(a)) {
    if (!is.arr(b) || a.length !== b.length) return false;

    for (var i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) return false;
    }

    return true;
  }

  return a === b;
}

var each = function each(obj, fn) {
  return obj.forEach(fn);
};

function eachProp(obj, fn, ctx) {
  if (is.arr(obj)) {
    for (var i = 0; i < obj.length; i++) {
      fn.call(ctx, obj[i], "".concat(i));
    }

    return;
  }

  for (var key in obj) {
    if (obj.hasOwnProperty(key)) {
      fn.call(ctx, obj[key], key);
    }
  }
}

var toArray = function toArray(a) {
  return is.und(a) ? [] : is.arr(a) ? a : [a];
};

function flush(queue, iterator) {
  if (queue.size) {
    var items = Array.from(queue);
    queue.clear();
    each(items, iterator);
  }
}

var flushCalls = function flushCalls(queue) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  return flush(queue, function (fn) {
    return fn.apply(void 0, args);
  });
};

var isSSR = function isSSR() {
  return typeof window === 'undefined' || !window.navigator || /ServerSideRendering|^Deno\//.test(window.navigator.userAgent);
};

var createStringInterpolator$1;
var to;
var colors$1 = null;
var skipAnimation = false;
var willAdvance = noop;

var assign = function assign(globals) {
  if (globals.to) to = globals.to;
  if (globals.now) reactSpringRafz_esm.raf.now = globals.now;
  if (globals.colors !== undefined) colors$1 = globals.colors;
  if (globals.skipAnimation != null) skipAnimation = globals.skipAnimation;
  if (globals.createStringInterpolator) createStringInterpolator$1 = globals.createStringInterpolator;
  if (globals.requestAnimationFrame) reactSpringRafz_esm.raf.use(globals.requestAnimationFrame);
  if (globals.batchedUpdates) reactSpringRafz_esm.raf.batchedUpdates = globals.batchedUpdates;
  if (globals.willAdvance) willAdvance = globals.willAdvance;
  if (globals.frameLoop) reactSpringRafz_esm.raf.frameLoop = globals.frameLoop;
};

var globals = /*#__PURE__*/Object.freeze({
  __proto__: null,

  get createStringInterpolator() {
    return createStringInterpolator$1;
  },

  get to() {
    return to;
  },

  get colors() {
    return colors$1;
  },

  get skipAnimation() {
    return skipAnimation;
  },

  get willAdvance() {
    return willAdvance;
  },

  assign: assign
});
var startQueue = new Set();
var currentFrame = [];
var prevFrame = [];
var priority = 0;
var frameLoop = {
  get idle() {
    return !startQueue.size && !currentFrame.length;
  },

  start: function start(animation) {
    if (priority > animation.priority) {
      startQueue.add(animation);
      reactSpringRafz_esm.raf.onStart(flushStartQueue);
    } else {
      startSafely(animation);
      reactSpringRafz_esm.raf(advance);
    }
  },
  advance: advance,
  sort: function sort(animation) {
    if (priority) {
      reactSpringRafz_esm.raf.onFrame(function () {
        return frameLoop.sort(animation);
      });
    } else {
      var prevIndex = currentFrame.indexOf(animation);

      if (~prevIndex) {
        currentFrame.splice(prevIndex, 1);
        startUnsafely(animation);
      }
    }
  },
  clear: function clear() {
    currentFrame = [];
    startQueue.clear();
  }
};

function flushStartQueue() {
  startQueue.forEach(startSafely);
  startQueue.clear();
  reactSpringRafz_esm.raf(advance);
}

function startSafely(animation) {
  if (!currentFrame.includes(animation)) startUnsafely(animation);
}

function startUnsafely(animation) {
  currentFrame.splice(findIndex(currentFrame, function (other) {
    return other.priority > animation.priority;
  }), 0, animation);
}

function advance(dt) {
  var nextFrame = prevFrame;

  for (var i = 0; i < currentFrame.length; i++) {
    var animation = currentFrame[i];
    priority = animation.priority;

    if (!animation.idle) {
      willAdvance(animation);
      animation.advance(dt);

      if (!animation.idle) {
        nextFrame.push(animation);
      }
    }
  }

  priority = 0;
  prevFrame = currentFrame;
  prevFrame.length = 0;
  currentFrame = nextFrame;
  return currentFrame.length > 0;
}

function findIndex(arr, test) {
  var index = arr.findIndex(test);
  return index < 0 ? arr.length : index;
}

var colors = {
  transparent: 0x00000000,
  aliceblue: 0xf0f8ffff,
  antiquewhite: 0xfaebd7ff,
  aqua: 0x00ffffff,
  aquamarine: 0x7fffd4ff,
  azure: 0xf0ffffff,
  beige: 0xf5f5dcff,
  bisque: 0xffe4c4ff,
  black: 0x000000ff,
  blanchedalmond: 0xffebcdff,
  blue: 0x0000ffff,
  blueviolet: 0x8a2be2ff,
  brown: 0xa52a2aff,
  burlywood: 0xdeb887ff,
  burntsienna: 0xea7e5dff,
  cadetblue: 0x5f9ea0ff,
  chartreuse: 0x7fff00ff,
  chocolate: 0xd2691eff,
  coral: 0xff7f50ff,
  cornflowerblue: 0x6495edff,
  cornsilk: 0xfff8dcff,
  crimson: 0xdc143cff,
  cyan: 0x00ffffff,
  darkblue: 0x00008bff,
  darkcyan: 0x008b8bff,
  darkgoldenrod: 0xb8860bff,
  darkgray: 0xa9a9a9ff,
  darkgreen: 0x006400ff,
  darkgrey: 0xa9a9a9ff,
  darkkhaki: 0xbdb76bff,
  darkmagenta: 0x8b008bff,
  darkolivegreen: 0x556b2fff,
  darkorange: 0xff8c00ff,
  darkorchid: 0x9932ccff,
  darkred: 0x8b0000ff,
  darksalmon: 0xe9967aff,
  darkseagreen: 0x8fbc8fff,
  darkslateblue: 0x483d8bff,
  darkslategray: 0x2f4f4fff,
  darkslategrey: 0x2f4f4fff,
  darkturquoise: 0x00ced1ff,
  darkviolet: 0x9400d3ff,
  deeppink: 0xff1493ff,
  deepskyblue: 0x00bfffff,
  dimgray: 0x696969ff,
  dimgrey: 0x696969ff,
  dodgerblue: 0x1e90ffff,
  firebrick: 0xb22222ff,
  floralwhite: 0xfffaf0ff,
  forestgreen: 0x228b22ff,
  fuchsia: 0xff00ffff,
  gainsboro: 0xdcdcdcff,
  ghostwhite: 0xf8f8ffff,
  gold: 0xffd700ff,
  goldenrod: 0xdaa520ff,
  gray: 0x808080ff,
  green: 0x008000ff,
  greenyellow: 0xadff2fff,
  grey: 0x808080ff,
  honeydew: 0xf0fff0ff,
  hotpink: 0xff69b4ff,
  indianred: 0xcd5c5cff,
  indigo: 0x4b0082ff,
  ivory: 0xfffff0ff,
  khaki: 0xf0e68cff,
  lavender: 0xe6e6faff,
  lavenderblush: 0xfff0f5ff,
  lawngreen: 0x7cfc00ff,
  lemonchiffon: 0xfffacdff,
  lightblue: 0xadd8e6ff,
  lightcoral: 0xf08080ff,
  lightcyan: 0xe0ffffff,
  lightgoldenrodyellow: 0xfafad2ff,
  lightgray: 0xd3d3d3ff,
  lightgreen: 0x90ee90ff,
  lightgrey: 0xd3d3d3ff,
  lightpink: 0xffb6c1ff,
  lightsalmon: 0xffa07aff,
  lightseagreen: 0x20b2aaff,
  lightskyblue: 0x87cefaff,
  lightslategray: 0x778899ff,
  lightslategrey: 0x778899ff,
  lightsteelblue: 0xb0c4deff,
  lightyellow: 0xffffe0ff,
  lime: 0x00ff00ff,
  limegreen: 0x32cd32ff,
  linen: 0xfaf0e6ff,
  magenta: 0xff00ffff,
  maroon: 0x800000ff,
  mediumaquamarine: 0x66cdaaff,
  mediumblue: 0x0000cdff,
  mediumorchid: 0xba55d3ff,
  mediumpurple: 0x9370dbff,
  mediumseagreen: 0x3cb371ff,
  mediumslateblue: 0x7b68eeff,
  mediumspringgreen: 0x00fa9aff,
  mediumturquoise: 0x48d1ccff,
  mediumvioletred: 0xc71585ff,
  midnightblue: 0x191970ff,
  mintcream: 0xf5fffaff,
  mistyrose: 0xffe4e1ff,
  moccasin: 0xffe4b5ff,
  navajowhite: 0xffdeadff,
  navy: 0x000080ff,
  oldlace: 0xfdf5e6ff,
  olive: 0x808000ff,
  olivedrab: 0x6b8e23ff,
  orange: 0xffa500ff,
  orangered: 0xff4500ff,
  orchid: 0xda70d6ff,
  palegoldenrod: 0xeee8aaff,
  palegreen: 0x98fb98ff,
  paleturquoise: 0xafeeeeff,
  palevioletred: 0xdb7093ff,
  papayawhip: 0xffefd5ff,
  peachpuff: 0xffdab9ff,
  peru: 0xcd853fff,
  pink: 0xffc0cbff,
  plum: 0xdda0ddff,
  powderblue: 0xb0e0e6ff,
  purple: 0x800080ff,
  rebeccapurple: 0x663399ff,
  red: 0xff0000ff,
  rosybrown: 0xbc8f8fff,
  royalblue: 0x4169e1ff,
  saddlebrown: 0x8b4513ff,
  salmon: 0xfa8072ff,
  sandybrown: 0xf4a460ff,
  seagreen: 0x2e8b57ff,
  seashell: 0xfff5eeff,
  sienna: 0xa0522dff,
  silver: 0xc0c0c0ff,
  skyblue: 0x87ceebff,
  slateblue: 0x6a5acdff,
  slategray: 0x708090ff,
  slategrey: 0x708090ff,
  snow: 0xfffafaff,
  springgreen: 0x00ff7fff,
  steelblue: 0x4682b4ff,
  tan: 0xd2b48cff,
  teal: 0x008080ff,
  thistle: 0xd8bfd8ff,
  tomato: 0xff6347ff,
  turquoise: 0x40e0d0ff,
  violet: 0xee82eeff,
  wheat: 0xf5deb3ff,
  white: 0xffffffff,
  whitesmoke: 0xf5f5f5ff,
  yellow: 0xffff00ff,
  yellowgreen: 0x9acd32ff
};
var NUMBER = '[-+]?\\d*\\.?\\d+';
var PERCENTAGE = NUMBER + '%';

function call() {
  for (var _len2 = arguments.length, parts = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    parts[_key2] = arguments[_key2];
  }

  return '\\(\\s*(' + parts.join(')\\s*,\\s*(') + ')\\s*\\)';
}

var rgb = new RegExp('rgb' + call(NUMBER, NUMBER, NUMBER));
var rgba = new RegExp('rgba' + call(NUMBER, NUMBER, NUMBER, NUMBER));
var hsl = new RegExp('hsl' + call(NUMBER, PERCENTAGE, PERCENTAGE));
var hsla = new RegExp('hsla' + call(NUMBER, PERCENTAGE, PERCENTAGE, NUMBER));
var hex3 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;
var hex4 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;
var hex6 = /^#([0-9a-fA-F]{6})$/;
var hex8 = /^#([0-9a-fA-F]{8})$/;

function normalizeColor(color) {
  var match;

  if (typeof color === 'number') {
    return color >>> 0 === color && color >= 0 && color <= 0xffffffff ? color : null;
  }

  if (match = hex6.exec(color)) return parseInt(match[1] + 'ff', 16) >>> 0;

  if (colors$1 && colors$1[color] !== undefined) {
    return colors$1[color];
  }

  if (match = rgb.exec(color)) {
    return (parse255(match[1]) << 24 | parse255(match[2]) << 16 | parse255(match[3]) << 8 | 0x000000ff) >>> 0;
  }

  if (match = rgba.exec(color)) {
    return (parse255(match[1]) << 24 | parse255(match[2]) << 16 | parse255(match[3]) << 8 | parse1(match[4])) >>> 0;
  }

  if (match = hex3.exec(color)) {
    return parseInt(match[1] + match[1] + match[2] + match[2] + match[3] + match[3] + 'ff', 16) >>> 0;
  }

  if (match = hex8.exec(color)) return parseInt(match[1], 16) >>> 0;

  if (match = hex4.exec(color)) {
    return parseInt(match[1] + match[1] + match[2] + match[2] + match[3] + match[3] + match[4] + match[4], 16) >>> 0;
  }

  if (match = hsl.exec(color)) {
    return (hslToRgb(parse360(match[1]), parsePercentage(match[2]), parsePercentage(match[3])) | 0x000000ff) >>> 0;
  }

  if (match = hsla.exec(color)) {
    return (hslToRgb(parse360(match[1]), parsePercentage(match[2]), parsePercentage(match[3])) | parse1(match[4])) >>> 0;
  }

  return null;
}

function hue2rgb(p, q, t) {
  if (t < 0) t += 1;
  if (t > 1) t -= 1;
  if (t < 1 / 6) return p + (q - p) * 6 * t;
  if (t < 1 / 2) return q;
  if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
  return p;
}

function hslToRgb(h, s, l) {
  var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
  var p = 2 * l - q;
  var r = hue2rgb(p, q, h + 1 / 3);
  var g = hue2rgb(p, q, h);
  var b = hue2rgb(p, q, h - 1 / 3);
  return Math.round(r * 255) << 24 | Math.round(g * 255) << 16 | Math.round(b * 255) << 8;
}

function parse255(str) {
  var _int = parseInt(str, 10);

  if (_int < 0) return 0;
  if (_int > 255) return 255;
  return _int;
}

function parse360(str) {
  var _int2 = parseFloat(str);

  return (_int2 % 360 + 360) % 360 / 360;
}

function parse1(str) {
  var num = parseFloat(str);
  if (num < 0) return 0;
  if (num > 1) return 255;
  return Math.round(num * 255);
}

function parsePercentage(str) {
  var _int3 = parseFloat(str);

  if (_int3 < 0) return 0;
  if (_int3 > 100) return 1;
  return _int3 / 100;
}

function colorToRgba(input) {
  var int32Color = normalizeColor(input);
  if (int32Color === null) return input;
  int32Color = int32Color || 0;
  var r = (int32Color & 0xff000000) >>> 24;
  var g = (int32Color & 0x00ff0000) >>> 16;
  var b = (int32Color & 0x0000ff00) >>> 8;
  var a = (int32Color & 0x000000ff) / 255;
  return "rgba(".concat(r, ", ").concat(g, ", ").concat(b, ", ").concat(a, ")");
}

var createInterpolator = function createInterpolator(range, output, extrapolate) {
  if (is.fun(range)) {
    return range;
  }

  if (is.arr(range)) {
    return createInterpolator({
      range: range,
      output: output,
      extrapolate: extrapolate
    });
  }

  if (is.str(range.output[0])) {
    return createStringInterpolator$1(range);
  }

  var config = range;
  var outputRange = config.output;
  var inputRange = config.range || [0, 1];
  var extrapolateLeft = config.extrapolateLeft || config.extrapolate || 'extend';
  var extrapolateRight = config.extrapolateRight || config.extrapolate || 'extend';

  var easing = config.easing || function (t) {
    return t;
  };

  return function (input) {
    var range = findRange(input, inputRange);
    return interpolate(input, inputRange[range], inputRange[range + 1], outputRange[range], outputRange[range + 1], easing, extrapolateLeft, extrapolateRight, config.map);
  };
};

function interpolate(input, inputMin, inputMax, outputMin, outputMax, easing, extrapolateLeft, extrapolateRight, map) {
  var result = map ? map(input) : input;

  if (result < inputMin) {
    if (extrapolateLeft === 'identity') return result;else if (extrapolateLeft === 'clamp') result = inputMin;
  }

  if (result > inputMax) {
    if (extrapolateRight === 'identity') return result;else if (extrapolateRight === 'clamp') result = inputMax;
  }

  if (outputMin === outputMax) return outputMin;
  if (inputMin === inputMax) return input <= inputMin ? outputMin : outputMax;
  if (inputMin === -Infinity) result = -result;else if (inputMax === Infinity) result = result - inputMin;else result = (result - inputMin) / (inputMax - inputMin);
  result = easing(result);
  if (outputMin === -Infinity) result = -result;else if (outputMax === Infinity) result = result + outputMin;else result = result * (outputMax - outputMin) + outputMin;
  return result;
}

function findRange(input, inputRange) {
  for (var i = 1; i < inputRange.length - 1; ++i) {
    if (inputRange[i] >= input) break;
  }

  return i - 1;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

var $get = Symbol["for"]('FluidValue.get');
var $observers = Symbol["for"]('FluidValue.observers');

var hasFluidValue = function hasFluidValue(arg) {
  return Boolean(arg && arg[$get]);
};

var getFluidValue = function getFluidValue(arg) {
  return arg && arg[$get] ? arg[$get]() : arg;
};

var getFluidObservers = function getFluidObservers(target) {
  return target[$observers] || null;
};

function callFluidObserver(observer, event) {
  if (observer.eventObserved) {
    observer.eventObserved(event);
  } else {
    observer(event);
  }
}

function callFluidObservers(target, event) {
  var observers = target[$observers];

  if (observers) {
    observers.forEach(function (observer) {
      callFluidObserver(observer, event);
    });
  }
}

var FluidValue = /*#__PURE__*/_rollupPluginBabelHelpers.createClass(function FluidValue(get) {
  _rollupPluginBabelHelpers.classCallCheck(this, FluidValue);

  this[$get] = void 0;
  this[$observers] = void 0;

  if (!get && !(get = this.get)) {
    throw Error('Unknown getter');
  }

  setFluidGetter(this, get);
});

var setFluidGetter = function setFluidGetter(target, get) {
  return setHidden(target, $get, get);
};

function addFluidObserver(target, observer) {
  if (target[$get]) {
    var observers = target[$observers];

    if (!observers) {
      setHidden(target, $observers, observers = new Set());
    }

    if (!observers.has(observer)) {
      observers.add(observer);

      if (target.observerAdded) {
        target.observerAdded(observers.size, observer);
      }
    }
  }

  return observer;
}

function removeFluidObserver(target, observer) {
  var observers = target[$observers];

  if (observers && observers.has(observer)) {
    var count = observers.size - 1;

    if (count) {
      observers["delete"](observer);
    } else {
      target[$observers] = null;
    }

    if (target.observerRemoved) {
      target.observerRemoved(count, observer);
    }
  }
}

var setHidden = function setHidden(target, key, value) {
  return Object.defineProperty(target, key, {
    value: value,
    writable: true,
    configurable: true
  });
};

var numberRegex = /[+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
var colorRegex = /(#(?:[0-9a-f]{2}){2,4}|(#[0-9a-f]{3})|(rgb|hsl)a?\((-?\d+%?[,\s]+){2,3}\s*[\d\.]+%?\))/gi;
var unitRegex = new RegExp("(".concat(numberRegex.source, ")(%|[a-z]+)"), 'i');
var rgbaRegex = /rgba\(([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+)\)/gi;
var cssVariableRegex = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/;

var variableToRgba = function variableToRgba(input) {
  var _parseCSSVariable = parseCSSVariable(input),
      _parseCSSVariable2 = _rollupPluginBabelHelpers.slicedToArray(_parseCSSVariable, 2),
      token = _parseCSSVariable2[0],
      fallback = _parseCSSVariable2[1];

  if (!token || isSSR()) {
    return input;
  }

  var value = window.getComputedStyle(document.documentElement).getPropertyValue(token);

  if (value) {
    return value.trim();
  } else if (fallback && fallback.startsWith('--')) {
    var _value = window.getComputedStyle(document.documentElement).getPropertyValue(fallback);

    if (_value) {
      return _value;
    } else {
      return input;
    }
  } else if (fallback && cssVariableRegex.test(fallback)) {
    return variableToRgba(fallback);
  } else if (fallback) {
    return fallback;
  }

  return input;
};

var parseCSSVariable = function parseCSSVariable(current) {
  var match = cssVariableRegex.exec(current);
  if (!match) return [,];

  var _match = _rollupPluginBabelHelpers.slicedToArray(match, 3),
      token = _match[1],
      fallback = _match[2];

  return [token, fallback];
};

var namedColorRegex;

var rgbaRound = function rgbaRound(_, p1, p2, p3, p4) {
  return "rgba(".concat(Math.round(p1), ", ").concat(Math.round(p2), ", ").concat(Math.round(p3), ", ").concat(p4, ")");
};

var createStringInterpolator = function createStringInterpolator(config) {
  if (!namedColorRegex) namedColorRegex = colors$1 ? new RegExp("(".concat(Object.keys(colors$1).join('|'), ")(?!\\w)"), 'g') : /^\b$/;
  var output = config.output.map(function (value) {
    return getFluidValue(value).replace(cssVariableRegex, variableToRgba).replace(colorRegex, colorToRgba).replace(namedColorRegex, colorToRgba);
  });
  var keyframes = output.map(function (value) {
    return value.match(numberRegex).map(Number);
  });
  var outputRanges = keyframes[0].map(function (_, i) {
    return keyframes.map(function (values) {
      if (!(i in values)) {
        throw Error('The arity of each "output" value must be equal');
      }

      return values[i];
    });
  });
  var interpolators = outputRanges.map(function (output) {
    return createInterpolator(_extends({}, config, {
      output: output
    }));
  });
  return function (input) {
    var _output$find;

    var missingUnit = !unitRegex.test(output[0]) && ((_output$find = output.find(function (value) {
      return unitRegex.test(value);
    })) == null ? void 0 : _output$find.replace(numberRegex, ''));
    var i = 0;
    return output[0].replace(numberRegex, function () {
      return "".concat(interpolators[i++](input)).concat(missingUnit || '');
    }).replace(rgbaRegex, rgbaRound);
  };
};

var prefix = 'react-spring: ';

var once = function once(fn) {
  var func = fn;
  var called = false;

  if (typeof func != 'function') {
    throw new TypeError("".concat(prefix, "once requires a function parameter"));
  }

  return function () {
    if (!called) {
      func.apply(void 0, arguments);
      called = true;
    }
  };
};

var warnInterpolate = once(console.warn);

function deprecateInterpolate() {
  warnInterpolate("".concat(prefix, "The \"interpolate\" function is deprecated in v9 (use \"to\" instead)"));
}

var warnDirectCall = once(console.warn);

function deprecateDirectCall() {
  warnDirectCall("".concat(prefix, "Directly calling start instead of using the api object is deprecated in v9 (use \".start\" instead), this will be removed in later 0.X.0 versions"));
}

function isAnimatedString(value) {
  return is.str(value) && (value[0] == '#' || /\d/.test(value) || !isSSR() && cssVariableRegex.test(value) || value in (colors$1 || {}));
}

var useLayoutEffect = typeof window !== 'undefined' && window.document && window.document.createElement ? React__namespace.useLayoutEffect : React__namespace.useEffect;

var useIsMounted = function useIsMounted() {
  var isMounted = React.useRef(false);
  useLayoutEffect(function () {
    isMounted.current = true;
    return function () {
      isMounted.current = false;
    };
  }, []);
  return isMounted;
};

function useForceUpdate() {
  var update = React.useState()[1];
  var isMounted = useIsMounted();
  return function () {
    if (isMounted.current) {
      update(Math.random());
    }
  };
}

function useMemoOne(getResult, inputs) {
  var _useState = React.useState(function () {
    return {
      inputs: inputs,
      result: getResult()
    };
  }),
      _useState2 = _rollupPluginBabelHelpers.slicedToArray(_useState, 1),
      initial = _useState2[0];

  var committed = React.useRef();
  var prevCache = committed.current;
  var cache = prevCache;

  if (cache) {
    var useCache = Boolean(inputs && cache.inputs && areInputsEqual(inputs, cache.inputs));

    if (!useCache) {
      cache = {
        inputs: inputs,
        result: getResult()
      };
    }
  } else {
    cache = initial;
  }

  React.useEffect(function () {
    committed.current = cache;

    if (prevCache == initial) {
      initial.inputs = initial.result = undefined;
    }
  }, [cache]);
  return cache.result;
}

function areInputsEqual(next, prev) {
  if (next.length !== prev.length) {
    return false;
  }

  for (var i = 0; i < next.length; i++) {
    if (next[i] !== prev[i]) {
      return false;
    }
  }

  return true;
}

var useOnce = function useOnce(effect) {
  return React.useEffect(effect, emptyDeps);
};

var emptyDeps = [];

function usePrev(value) {
  var prevRef = React.useRef();
  React.useEffect(function () {
    prevRef.current = value;
  });
  return prevRef.current;
}

exports.raf = reactSpringRafz_esm.raf;
exports.FluidValue = FluidValue;
exports.Globals = globals;
exports.addFluidObserver = addFluidObserver;
exports.callFluidObserver = callFluidObserver;
exports.callFluidObservers = callFluidObservers;
exports.colorToRgba = colorToRgba;
exports.colors = colors;
exports.createInterpolator = createInterpolator;
exports.createStringInterpolator = createStringInterpolator;
exports.defineHidden = defineHidden;
exports.deprecateDirectCall = deprecateDirectCall;
exports.deprecateInterpolate = deprecateInterpolate;
exports.each = each;
exports.eachProp = eachProp;
exports.flush = flush;
exports.flushCalls = flushCalls;
exports.frameLoop = frameLoop;
exports.getFluidObservers = getFluidObservers;
exports.getFluidValue = getFluidValue;
exports.hasFluidValue = hasFluidValue;
exports.hex3 = hex3;
exports.hex4 = hex4;
exports.hex6 = hex6;
exports.hex8 = hex8;
exports.hsl = hsl;
exports.hsla = hsla;
exports.is = is;
exports.isAnimatedString = isAnimatedString;
exports.isEqual = isEqual;
exports.isSSR = isSSR;
exports.noop = noop;
exports.removeFluidObserver = removeFluidObserver;
exports.rgb = rgb;
exports.rgba = rgba;
exports.setFluidGetter = setFluidGetter;
exports.toArray = toArray;
exports.useForceUpdate = useForceUpdate;
exports.useLayoutEffect = useLayoutEffect;
exports.useMemoOne = useMemoOne;
exports.useOnce = useOnce;
exports.usePrev = usePrev;
//# sourceMappingURL=react-spring-shared.esm.js.map
