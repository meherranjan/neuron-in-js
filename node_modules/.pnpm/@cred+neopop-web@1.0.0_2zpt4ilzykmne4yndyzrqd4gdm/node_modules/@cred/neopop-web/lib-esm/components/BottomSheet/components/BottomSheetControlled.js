import { objectWithoutProperties as _objectWithoutProperties, extends as _extends, objectSpread2 as _objectSpread2, slicedToArray as _slicedToArray, asyncToGenerator as _asyncToGenerator, regeneratorRuntime as _regeneratorRuntime } from '../../../_virtual/_rollupPluginBabelHelpers.js';
import React__default, { useRef, useEffect } from 'react';
import '../../../node_modules/@react-spring/web/dist/react-spring-web.esm.js';
import { useDrag } from '../../../node_modules/@use-gesture/react/dist/use-gesture-react.esm.js';
import Portal from '../../../node_modules/react-portal/es/PortalCompat.js';
import '../../../node_modules/react-portal/es/PortalWithState.js';
import useDelayMount from '../../../hooks/useDelayMount.js';
import useClientHeight from '../../../hooks/useClientHeight.js';
import { Wraper, Overlay, Card, Notch, Sheet, Content, GapFiller, CardCustom } from '../styles.js';
import { useSpring } from '../../../node_modules/@react-spring/core/dist/react-spring-core.esm.js';
import { r as rubberbandIfOutOfBounds } from '../../../node_modules/@use-gesture/core/dist/maths-b2a210f4.esm.js';

var _excluded = ["onRest"],
    _excluded2 = ["children", "node", "handleClose", "blocking", "onCloseEnd", "onBeforeClose", "open", "maxHeight", "sheetStyle", "sheetPlunkColor", "overlayColor"],
    _excluded3 = ["children", "node", "handleClose", "blocking", "onCloseEnd", "onBeforeClose", "open", "maxHeight", "sheetStyle", "sheetPlunkColor", "overlayColor", "shouldShowNotch", "shouldShowOverlay"];

var twoThirdOf = function twoThirdOf(number) {
  return number * 2 / 3;
};

var useBottomSheetMechanics = function useBottomSheetMechanics(_ref) {
  var open = _ref.open,
      handleClose = _ref.handleClose,
      onBeforeClose = _ref.onBeforeClose,
      onCloseEnd = _ref.onCloseEnd,
      blocking = _ref.blocking,
      onOpenEnd = _ref.onOpenEnd;
  var mounted = useDelayMount(open);

  var _useSpring = useSpring(function () {
    return {
      y: '100%',
      scaleY: 1,
      opacity: 0,
      config: {
        tension: 180,
        friction: 25
      }
    };
  }),
      _useSpring2 = _slicedToArray(_useSpring, 2),
      _useSpring2$ = _useSpring2[0],
      y = _useSpring2$.y,
      opacity = _useSpring2$.opacity,
      scaleY = _useSpring2$.scaleY,
      api = _useSpring2[1];

  var _useClientHeight = useClientHeight(),
      _useClientHeight2 = _slicedToArray(_useClientHeight, 2),
      cardRef = _useClientHeight2[0],
      sheetHeight = _useClientHeight2[1];

  var preventScrollRef = useRef(false);
  var closeInProgressRef = useRef(false);

  var requestCloseBottomSheet = function requestCloseBottomSheet() {
    if (closeInProgressRef.current) {
      return;
    }

    closeInProgressRef.current = true;
    handleClose();
  };

  var springApiSet = /*#__PURE__*/function () {
    var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(_ref2) {
      var _ref2$onRest, _onRest, option;

      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _ref2$onRest = _ref2.onRest, _onRest = _ref2$onRest === void 0 ? function () {} : _ref2$onRest, option = _objectWithoutProperties(_ref2, _excluded);
              return _context.abrupt("return", new Promise(function (resolve) {
                api.start(_objectSpread2(_objectSpread2({}, option), {}, {
                  onRest: function onRest() {
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                      args[_key] = arguments[_key];
                    }

                    resolve(args);
                    _onRest === null || _onRest === void 0 ? void 0 : _onRest.apply(void 0, args);
                  }
                }));
              }));

            case 2:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function springApiSet(_x) {
      return _ref3.apply(this, arguments);
    };
  }();

  var closeBottomSheet = function closeBottomSheet() {
    if (onBeforeClose instanceof Function) {
      onBeforeClose();
    }

    closeInProgressRef.current = true;
    springApiSet({
      opacity: 0,
      y: sheetHeight ? "".concat(sheetHeight + 200, "px") : '115%',
      onRest: function onRest() {
        var event = arguments.length <= 0 ? undefined : arguments[0];

        if (event !== null && event !== void 0 && event.finished && !(event !== null && event !== void 0 && event.cancelled)) {
          onCloseEnd();
        }
      }
    });
  };

  useEffect(function () {
    _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (!mounted) {
                _context2.next = 7;
                break;
              }

              _context2.next = 3;
              return springApiSet({
                opacity: 1,
                y: '0px'
              });

            case 3:
              if (onOpenEnd instanceof Function) {
                onOpenEnd();
              }

              closeInProgressRef.current = false;
              _context2.next = 8;
              break;

            case 7:
              closeBottomSheet();

            case 8:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }))();
  }, [mounted]);
  useEffect(function () {
    var element = cardRef.ref.current;

    var preventScrolling = function preventScrolling(e) {
      if (preventScrollRef.current) {
        e.preventDefault();
      }
    };

    element.addEventListener('scroll', preventScrolling);
    element.addEventListener('touchmove', preventScrolling);
    return function () {
      element.removeEventListener('scroll', preventScrolling);
      element.removeEventListener('touchmove', preventScrolling);
    };
  }, [cardRef.ref.current]);

  var handleDrag = function handleDrag(_ref5) {
    var _ref5$args = _ref5.args;
    _ref5$args = _ref5$args === void 0 ? [] : _ref5$args;

    var _ref5$args2 = _slicedToArray(_ref5$args, 1),
        _ref5$args2$ = _ref5$args2[0];

    _ref5$args2$ = _ref5$args2$ === void 0 ? {} : _ref5$args2$;

    var _ref5$args2$$closeOnT = _ref5$args2$.closeOnTap,
        closeOnTap = _ref5$args2$$closeOnT === void 0 ? false : _ref5$args2$$closeOnT,
        _ref5$args2$$contentS = _ref5$args2$.contentSheet,
        contentSheet = _ref5$args2$$contentS === void 0 ? false : _ref5$args2$$contentS,
        cancel = _ref5.cancel,
        active = _ref5.active,
        tap = _ref5.tap,
        _ref5$velocity = _slicedToArray(_ref5.velocity, 2),
        _ref5$velocity$ = _ref5$velocity[1],
        vy = _ref5$velocity$ === void 0 ? 0 : _ref5$velocity$,
        _ref5$movement = _slicedToArray(_ref5.movement, 2),
        my = _ref5$movement[1],
        _ref5$direction = _slicedToArray(_ref5.direction, 2),
        dy = _ref5$direction[1];

    if (closeInProgressRef.current) {
      return;
    }

    if (tap && closeOnTap) {
      requestCloseBottomSheet();
      return;
    }

    if (contentSheet) {
      var elem = cardRef.ref.current;
      preventScrollRef.current = dy > 0 && elem.scrollTop === 0;
    } // it's not the correct Physics formula just a measure of user intent


    var predictedDistance = my * vy;

    if (!blocking && predictedDistance >= twoThirdOf(sheetHeight)) {
      cancel();
      requestCloseBottomSheet();
      return;
    }

    var yValue = rubberbandIfOutOfBounds(my, -1, sheetHeight + 100, 0.12);
    springApiSet({
      y: active ? "".concat(yValue, "px") : '0px',
      immediate: active,
      scaleY: active && yValue < 0 ? Math.ceil(Math.abs(yValue)) : 1
    });
  };

  var bind = useDrag(handleDrag, {
    filterTaps: true
  });
  return {
    requestCloseBottomSheet: requestCloseBottomSheet,
    opacity: opacity,
    y: y,
    bind: bind,
    cardRef: cardRef,
    scaleY: scaleY
  };
};

var BottomSheetControlled = function BottomSheetControlled(_ref6) {
  var children = _ref6.children,
      node = _ref6.node,
      handleClose = _ref6.handleClose,
      _ref6$blocking = _ref6.blocking,
      blocking = _ref6$blocking === void 0 ? false : _ref6$blocking,
      onCloseEnd = _ref6.onCloseEnd,
      onBeforeClose = _ref6.onBeforeClose,
      open = _ref6.open,
      _ref6$maxHeight = _ref6.maxHeight,
      maxHeight = _ref6$maxHeight === void 0 ? '85%' : _ref6$maxHeight,
      sheetStyle = _ref6.sheetStyle,
      sheetPlunkColor = _ref6.sheetPlunkColor,
      overlayColor = _ref6.overlayColor,
      props = _objectWithoutProperties(_ref6, _excluded2);

  var _useBottomSheetMechan = useBottomSheetMechanics({
    open: open,
    handleClose: handleClose,
    onBeforeClose: onBeforeClose,
    onCloseEnd: onCloseEnd,
    blocking: blocking
  }),
      requestCloseBottomSheet = _useBottomSheetMechan.requestCloseBottomSheet,
      opacity = _useBottomSheetMechan.opacity,
      y = _useBottomSheetMechan.y,
      bind = _useBottomSheetMechan.bind,
      cardRef = _useBottomSheetMechan.cardRef,
      scaleY = _useBottomSheetMechan.scaleY;

  return /*#__PURE__*/React__default.createElement(Portal, {
    node: node || document.body
  }, /*#__PURE__*/React__default.createElement(Wraper, props, /*#__PURE__*/React__default.createElement(Overlay, _extends({
    onKeyDown: function onKeyDown(event) {
      if (event.key === 'Escape' && !blocking) {
        // Always stop propagation, to avoid weirdness for bottom sheets inside other bottom sheets
        event.stopPropagation();
        requestCloseBottomSheet();
      }
    },
    style: {
      opacity: opacity,
      backgroundColor: overlayColor
    }
  }, bind({
    closeOnTap: !blocking
  }))), /*#__PURE__*/React__default.createElement(Card, {
    $sheetShadowColor: sheetPlunkColor,
    $maxHeight: maxHeight,
    style: _objectSpread2(_objectSpread2({}, sheetStyle), {}, {
      y: y
    })
  }, /*#__PURE__*/React__default.createElement(Notch, bind()), /*#__PURE__*/React__default.createElement(Sheet, _extends({}, cardRef, bind({
    contentSheet: true
  })), /*#__PURE__*/React__default.createElement(Content, null, children))), /*#__PURE__*/React__default.createElement(GapFiller, {
    style: {
      scaleY: scaleY,
      opacity: opacity
    }
  })));
};

var BottomSheetControlledCustom = function BottomSheetControlledCustom(_ref7) {
  var children = _ref7.children,
      node = _ref7.node,
      handleClose = _ref7.handleClose,
      _ref7$blocking = _ref7.blocking,
      blocking = _ref7$blocking === void 0 ? false : _ref7$blocking,
      onCloseEnd = _ref7.onCloseEnd,
      onBeforeClose = _ref7.onBeforeClose,
      open = _ref7.open,
      _ref7$maxHeight = _ref7.maxHeight,
      maxHeight = _ref7$maxHeight === void 0 ? '85%' : _ref7$maxHeight,
      sheetStyle = _ref7.sheetStyle;
      _ref7.sheetPlunkColor;
      var overlayColor = _ref7.overlayColor,
      _ref7$shouldShowNotch = _ref7.shouldShowNotch,
      shouldShowNotch = _ref7$shouldShowNotch === void 0 ? true : _ref7$shouldShowNotch,
      _ref7$shouldShowOverl = _ref7.shouldShowOverlay,
      shouldShowOverlay = _ref7$shouldShowOverl === void 0 ? true : _ref7$shouldShowOverl,
      props = _objectWithoutProperties(_ref7, _excluded3);

  var _useBottomSheetMechan2 = useBottomSheetMechanics({
    open: open,
    handleClose: handleClose,
    onBeforeClose: onBeforeClose,
    onCloseEnd: onCloseEnd,
    blocking: blocking
  }),
      requestCloseBottomSheet = _useBottomSheetMechan2.requestCloseBottomSheet,
      opacity = _useBottomSheetMechan2.opacity,
      y = _useBottomSheetMechan2.y,
      bind = _useBottomSheetMechan2.bind,
      cardRef = _useBottomSheetMechan2.cardRef;

  return /*#__PURE__*/React__default.createElement(Portal, {
    node: node || document.body
  }, /*#__PURE__*/React__default.createElement(Wraper, props, shouldShowOverlay ? /*#__PURE__*/React__default.createElement(Overlay, _extends({
    onKeyDown: function onKeyDown(event) {
      if (event.key === 'Escape' && !blocking) {
        // Always stop propagation, to avoid weirdness for bottom sheets inside other bottom sheets
        event.stopPropagation();
        requestCloseBottomSheet();
      }
    },
    style: {
      opacity: opacity,
      backgroundColor: overlayColor
    }
  }, bind({
    closeOnTap: !blocking
  }))) : null, /*#__PURE__*/React__default.createElement(CardCustom, {
    $maxHeight: maxHeight,
    style: _objectSpread2(_objectSpread2({}, sheetStyle), {}, {
      y: y
    })
  }, shouldShowNotch ? /*#__PURE__*/React__default.createElement(Notch, bind()) : null, /*#__PURE__*/React__default.createElement(Sheet, _extends({}, cardRef, bind({
    contentSheet: true
  })), children))));
};

export { BottomSheetControlledCustom, BottomSheetControlled as default, useBottomSheetMechanics };
//# sourceMappingURL=BottomSheetControlled.js.map
