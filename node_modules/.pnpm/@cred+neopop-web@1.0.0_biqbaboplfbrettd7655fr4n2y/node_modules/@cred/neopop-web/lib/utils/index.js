'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _rollupPluginBabelHelpers = require('../_virtual/_rollupPluginBabelHelpers.js');
var styled = require('styled-components');
require('../components/Button/types.js');
var types = require('../components/Typography/types.js');
require('../components/Helpers/types.js');

var hexToRGBA = function hexToRGBA(hex, alpha) {
  var r = parseInt(hex.slice(1, 3), 16);
  var g = parseInt(hex.slice(3, 5), 16);
  var b = parseInt(hex.slice(5, 7), 16);
  if (alpha) return "rgba(".concat(r, ",").concat(g, ",").concat(b, ", ").concat(alpha, ")");
  return "rgb(".concat(r, ",").concat(g, ",").concat(b, ")");
};
var isEmpty = function isEmpty(value) {
  return value === undefined || value === null || value === '' || value === {} || value === [];
};
var Currencies = {
  dollar: {
    countryCode: 'US',
    currency: 'USD'
  },
  inr: {
    countryCode: 'IN',
    currency: 'INR'
  }
};
var currencyFormatter = function currencyFormatter(rupees) {
  var _window;

  var fallback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  var minimumFractionDigits = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var cur = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'inr';
  var formatNumber = Number(rupees);

  if (formatNumber !== 0 && !formatNumber || Number.isNaN(formatNumber)) {
    if (fallback) return fallback;
    return '';
  } // console.log(cur);


  if ((_window = window) !== null && _window !== void 0 && _window.Intl) {
    var obj = Currencies[cur];

    if (obj) {
      return new Intl.NumberFormat("en-".concat(obj.countryCode), {
        style: 'currency',
        currency: "".concat(obj.currency),
        minimumFractionDigits: minimumFractionDigits,
        maximumFractionDigits: 2
      }).format(formatNumber).replace(/\s/g, '');
    }
  }

  return formatNumber;
};
var generateTextStyle = function generateTextStyle() {
  var _LINE_HEIGHT_MULTIPLI;

  var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : types.FontType.BODY;
  var fontSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 14;
  var fontWeight = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : types.FontWeights.REGULAR;
  var color = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '#FFFFFF';
  var LINE_HEIGHT_MULTIPLIER = (_LINE_HEIGHT_MULTIPLI = {}, _rollupPluginBabelHelpers.defineProperty(_LINE_HEIGHT_MULTIPLI, types.FontType.HEADING, 1.25), _rollupPluginBabelHelpers.defineProperty(_LINE_HEIGHT_MULTIPLI, types.FontType.CAPS, 1.25), _rollupPluginBabelHelpers.defineProperty(_LINE_HEIGHT_MULTIPLI, types.FontType.BODY, 1.5), _rollupPluginBabelHelpers.defineProperty(_LINE_HEIGHT_MULTIPLI, types.FontType.SERIF_HEADING, 1.25), _LINE_HEIGHT_MULTIPLI);

  var getLetterSpacing = function getLetterSpacing(fType, fSize, fWeight) {
    switch (fType) {
      case types.FontType.HEADING:
        switch (fWeight) {
          case types.FontWeights.EXTRA_BOLD:
            return fSize >= 44 ? 0 : 0.2;

          case types.FontWeights.BOLD:
            return fSize >= 13 ? 0.2 : 0.4;

          case types.FontWeights.SEMI_BOLD:
            return fSize >= 18 ? 0.2 : 0.4;

          default:
            return 0.2;
        }

      case types.FontType.CAPS:
        if (fSize > 8) return 2;
        return 1;

      case types.FontType.BODY:
        return 0.4;

      case types.FontType.SERIF_HEADING:
        return 0.2;

      default:
        return 0.4;
    }
  };

  var letterSpacing = getLetterSpacing(type, fontSize, fontWeight);
  return styled.css(["font-size:", "px;font-style:normal;font-weight:", ";line-height:", "px;letter-spacing:", "px;color:", ";", ""], fontSize, fontWeight, Math.round(fontSize * LINE_HEIGHT_MULTIPLIER[type]), letterSpacing, color !== null && color !== void 0 ? color : '', type === types.FontType.CAPS ? styled.css(["text-transform:uppercase;"]) : '');
};
function getRandomInt(min, max) {
  var minN = Math.ceil(min);
  var maxN = Math.floor(max);
  return Math.floor(Math.random() * (maxN - minN + 1)) + minN;
}
var isImageLoaded = function isImageLoaded(src) {
  return new Promise(function (resolve, reject) {
    var image = new Image();
    image.src = src;
    image.addEventListener('load', function () {
      resolve(true);
    });
    image.addEventListener('error', function () {
      reject();
    });
  });
};

function isObject(item) {
  return item instanceof Object && !Array.isArray(item);
}

function mergeDeep(target) {
  for (var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    sources[_key - 1] = arguments[_key];
  }

  if (!sources.length) return target;
  var source = sources.shift();

  if (isObject(target) && isObject(source)) {
    for (var _key2 in source) {
      if (isObject(source[_key2])) {
        if (!target[_key2]) Object.assign(target, _rollupPluginBabelHelpers.defineProperty({}, _key2, {}));
        mergeDeep(target[_key2], source[_key2]);
      } else {
        Object.assign(target, _rollupPluginBabelHelpers.defineProperty({}, _key2, source[_key2]));
      }
    }
  }

  return mergeDeep.apply(void 0, [target].concat(sources));
}

exports.currencyFormatter = currencyFormatter;
exports.generateTextStyle = generateTextStyle;
exports.getRandomInt = getRandomInt;
exports.hexToRGBA = hexToRGBA;
exports.isEmpty = isEmpty;
exports.isImageLoaded = isImageLoaded;
exports.mergeDeep = mergeDeep;
//# sourceMappingURL=index.js.map
