'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _rollupPluginBabelHelpers = require('../../../../_virtual/_rollupPluginBabelHelpers.js');
var mathsB2a210f4_esm = require('./maths-b2a210f4.esm.js');

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

var EVENT_TYPE_MAP = {
  pointer: {
    start: 'down',
    change: 'move',
    end: 'up'
  },
  mouse: {
    start: 'down',
    change: 'move',
    end: 'up'
  },
  touch: {
    start: 'start',
    change: 'move',
    end: 'end'
  },
  gesture: {
    start: 'start',
    change: 'change',
    end: 'end'
  }
};

function capitalize(string) {
  if (!string) return '';
  return string[0].toUpperCase() + string.slice(1);
}

var actionsWithoutCaptureSupported = ['enter', 'leave'];

function hasCapture() {
  var capture = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
  var actionKey = arguments.length > 1 ? arguments[1] : undefined;
  return capture && !actionsWithoutCaptureSupported.includes(actionKey);
}

function toHandlerProp(device) {
  var action = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  var capture = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var deviceProps = EVENT_TYPE_MAP[device];
  var actionKey = deviceProps ? deviceProps[action] || action : action;
  return 'on' + capitalize(device) + capitalize(actionKey) + (hasCapture(capture, actionKey) ? 'Capture' : '');
}

var pointerCaptureEvents = ['gotpointercapture', 'lostpointercapture'];

function parseProp(prop) {
  var eventKey = prop.substring(2).toLowerCase();
  var passive = !!~eventKey.indexOf('passive');
  if (passive) eventKey = eventKey.replace('passive', '');
  var captureKey = pointerCaptureEvents.includes(eventKey) ? 'capturecapture' : 'capture';
  var capture = !!~eventKey.indexOf(captureKey);
  if (capture) eventKey = eventKey.replace('capture', '');
  return {
    device: eventKey,
    capture: capture,
    passive: passive
  };
}

function toDomEventType(device) {
  var action = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  var deviceProps = EVENT_TYPE_MAP[device];
  var actionKey = deviceProps ? deviceProps[action] || action : action;
  return device + actionKey;
}

function isTouch(event) {
  return 'touches' in event;
}

function getPointerType(event) {
  if (isTouch(event)) return 'touch';
  if ('pointerType' in event) return event.pointerType;
  return 'mouse';
}

function getCurrentTargetTouchList(event) {
  return Array.from(event.touches).filter(function (e) {
    var _event$currentTarget, _event$currentTarget$;

    return e.target === event.currentTarget || ((_event$currentTarget = event.currentTarget) === null || _event$currentTarget === void 0 ? void 0 : (_event$currentTarget$ = _event$currentTarget.contains) === null || _event$currentTarget$ === void 0 ? void 0 : _event$currentTarget$.call(_event$currentTarget, e.target));
  });
}

function getTouchList(event) {
  return event.type === 'touchend' || event.type === 'touchcancel' ? event.changedTouches : event.targetTouches;
}

function getValueEvent(event) {
  return isTouch(event) ? getTouchList(event)[0] : event;
}

function touchIds(event) {
  return getCurrentTargetTouchList(event).map(function (touch) {
    return touch.identifier;
  });
}

function pointerId(event) {
  var valueEvent = getValueEvent(event);
  return isTouch(event) ? valueEvent.identifier : valueEvent.pointerId;
}

function pointerValues(event) {
  var valueEvent = getValueEvent(event);
  return [valueEvent.clientX, valueEvent.clientY];
}

function getEventDetails(event) {
  var payload = {};
  if ('buttons' in event) payload.buttons = event.buttons;

  if ('shiftKey' in event) {
    var shiftKey = event.shiftKey,
        altKey = event.altKey,
        metaKey = event.metaKey,
        ctrlKey = event.ctrlKey;
    Object.assign(payload, {
      shiftKey: shiftKey,
      altKey: altKey,
      metaKey: metaKey,
      ctrlKey: ctrlKey
    });
  }

  return payload;
}

function call(v) {
  if (typeof v === 'function') {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    return v.apply(void 0, args);
  } else {
    return v;
  }
}

function noop() {}

function chain() {
  for (var _len2 = arguments.length, fns = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    fns[_key2] = arguments[_key2];
  }

  if (fns.length === 0) return noop;
  if (fns.length === 1) return fns[0];
  return function () {
    var result;

    var _iterator = _rollupPluginBabelHelpers.createForOfIteratorHelper(fns),
        _step2;

    try {
      for (_iterator.s(); !(_step2 = _iterator.n()).done;) {
        var fn = _step2.value;
        result = fn.apply(this, arguments) || result;
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    return result;
  };
}

function assignDefault(value, fallback) {
  return Object.assign({}, fallback, value || {});
}

var BEFORE_LAST_KINEMATICS_DELAY = 32;

var Engine = /*#__PURE__*/function () {
  function Engine(ctrl, args, key) {
    _rollupPluginBabelHelpers.classCallCheck(this, Engine);

    this.ctrl = ctrl;
    this.args = args;
    this.key = key;

    if (!this.state) {
      this.state = {};
      this.computeValues([0, 0]);
      this.computeInitial();
      if (this.init) this.init();
      this.reset();
    }
  }

  _rollupPluginBabelHelpers.createClass(Engine, [{
    key: "state",
    get: function get() {
      return this.ctrl.state[this.key];
    },
    set: function set(state) {
      this.ctrl.state[this.key] = state;
    }
  }, {
    key: "shared",
    get: function get() {
      return this.ctrl.state.shared;
    }
  }, {
    key: "eventStore",
    get: function get() {
      return this.ctrl.gestureEventStores[this.key];
    }
  }, {
    key: "timeoutStore",
    get: function get() {
      return this.ctrl.gestureTimeoutStores[this.key];
    }
  }, {
    key: "config",
    get: function get() {
      return this.ctrl.config[this.key];
    }
  }, {
    key: "sharedConfig",
    get: function get() {
      return this.ctrl.config.shared;
    }
  }, {
    key: "handler",
    get: function get() {
      return this.ctrl.handlers[this.key];
    }
  }, {
    key: "reset",
    value: function reset() {
      var state = this.state,
          shared = this.shared,
          ingKey = this.ingKey,
          args = this.args;
      shared[ingKey] = state._active = state.active = state._blocked = state._force = false;
      state._step = [false, false];
      state.intentional = false;
      state._movement = [0, 0];
      state._distance = [0, 0];
      state._direction = [0, 0];
      state._delta = [0, 0];
      state._bounds = [[-Infinity, Infinity], [-Infinity, Infinity]];
      state.args = args;
      state.axis = undefined;
      state.memo = undefined;
      state.elapsedTime = 0;
      state.direction = [0, 0];
      state.distance = [0, 0];
      state.overflow = [0, 0];
      state._movementBound = [false, false];
      state.velocity = [0, 0];
      state.movement = [0, 0];
      state.delta = [0, 0];
      state.timeStamp = 0;
    }
  }, {
    key: "start",
    value: function start(event) {
      var state = this.state;
      var config = this.config;

      if (!state._active) {
        this.reset();
        this.computeInitial();
        state._active = true;
        state.target = event.target;
        state.currentTarget = event.currentTarget;
        state.lastOffset = config.from ? call(config.from, state) : state.offset;
        state.offset = state.lastOffset;
      }

      state.startTime = state.timeStamp = event.timeStamp;
    }
  }, {
    key: "computeValues",
    value: function computeValues(values) {
      var state = this.state;
      state._values = values;
      state.values = this.config.transform(values);
    }
  }, {
    key: "computeInitial",
    value: function computeInitial() {
      var state = this.state;
      state._initial = state._values;
      state.initial = state.values;
    }
  }, {
    key: "compute",
    value: function compute(event) {
      var state = this.state,
          config = this.config,
          shared = this.shared;
      state.args = this.args;
      var dt = 0;

      if (event) {
        state.event = event;
        if (config.preventDefault && event.cancelable) state.event.preventDefault();
        state.type = event.type;
        shared.touches = this.ctrl.pointerIds.size || this.ctrl.touchIds.size;
        shared.locked = !!document.pointerLockElement;
        Object.assign(shared, getEventDetails(event));
        shared.down = shared.pressed = shared.buttons % 2 === 1 || shared.touches > 0;
        dt = event.timeStamp - state.timeStamp;
        state.timeStamp = event.timeStamp;
        state.elapsedTime = state.timeStamp - state.startTime;
      }

      if (state._active) {
        var _absoluteDelta = state._delta.map(Math.abs);

        mathsB2a210f4_esm.V.addTo(state._distance, _absoluteDelta);
      }

      if (this.axisIntent) this.axisIntent(event);

      var _state$_movement = _rollupPluginBabelHelpers.slicedToArray(state._movement, 2),
          _m0 = _state$_movement[0],
          _m1 = _state$_movement[1];

      var _config$threshold = _rollupPluginBabelHelpers.slicedToArray(config.threshold, 2),
          t0 = _config$threshold[0],
          t1 = _config$threshold[1];

      var _step = state._step,
          values = state.values;

      if (config.hasCustomTransform) {
        if (_step[0] === false) _step[0] = Math.abs(_m0) >= t0 && values[0];
        if (_step[1] === false) _step[1] = Math.abs(_m1) >= t1 && values[1];
      } else {
        if (_step[0] === false) _step[0] = Math.abs(_m0) >= t0 && Math.sign(_m0) * t0;
        if (_step[1] === false) _step[1] = Math.abs(_m1) >= t1 && Math.sign(_m1) * t1;
      }

      state.intentional = _step[0] !== false || _step[1] !== false;
      if (!state.intentional) return;
      var movement = [0, 0];

      if (config.hasCustomTransform) {
        var _values2 = _rollupPluginBabelHelpers.slicedToArray(values, 2),
            v0 = _values2[0],
            v1 = _values2[1];

        movement[0] = _step[0] !== false ? v0 - _step[0] : 0;
        movement[1] = _step[1] !== false ? v1 - _step[1] : 0;
      } else {
        movement[0] = _step[0] !== false ? _m0 - _step[0] : 0;
        movement[1] = _step[1] !== false ? _m1 - _step[1] : 0;
      }

      if (this.restrictToAxis && !state._blocked) this.restrictToAxis(movement);
      var previousOffset = state.offset;
      var gestureIsActive = state._active && !state._blocked || state.active;

      if (gestureIsActive) {
        state.first = state._active && !state.active;
        state.last = !state._active && state.active;
        state.active = shared[this.ingKey] = state._active;

        if (event) {
          if (state.first) {
            if ('bounds' in config) state._bounds = call(config.bounds, state);
            if (this.setup) this.setup();
          }

          state.movement = movement;
          this.computeOffset();
        }
      }

      var _state$offset = _rollupPluginBabelHelpers.slicedToArray(state.offset, 2),
          ox = _state$offset[0],
          oy = _state$offset[1];

      var _state$_bounds = _rollupPluginBabelHelpers.slicedToArray(state._bounds, 2),
          _state$_bounds$ = _rollupPluginBabelHelpers.slicedToArray(_state$_bounds[0], 2),
          x0 = _state$_bounds$[0],
          x1 = _state$_bounds$[1],
          _state$_bounds$2 = _rollupPluginBabelHelpers.slicedToArray(_state$_bounds[1], 2),
          y0 = _state$_bounds$2[0],
          y1 = _state$_bounds$2[1];

      state.overflow = [ox < x0 ? -1 : ox > x1 ? 1 : 0, oy < y0 ? -1 : oy > y1 ? 1 : 0];
      state._movementBound[0] = state.overflow[0] ? state._movementBound[0] === false ? state._movement[0] : state._movementBound[0] : false;
      state._movementBound[1] = state.overflow[1] ? state._movementBound[1] === false ? state._movement[1] : state._movementBound[1] : false;
      var rubberband = state._active ? config.rubberband || [0, 0] : [0, 0];
      state.offset = mathsB2a210f4_esm.c(state._bounds, state.offset, rubberband);
      state.delta = mathsB2a210f4_esm.V.sub(state.offset, previousOffset);
      this.computeMovement();

      if (gestureIsActive && (!state.last || dt > BEFORE_LAST_KINEMATICS_DELAY)) {
        state.delta = mathsB2a210f4_esm.V.sub(state.offset, previousOffset);
        var absoluteDelta = state.delta.map(Math.abs);
        mathsB2a210f4_esm.V.addTo(state.distance, absoluteDelta);
        state.direction = state.delta.map(Math.sign);
        state._direction = state._delta.map(Math.sign);

        if (!state.first && dt > 0) {
          state.velocity = [absoluteDelta[0] / dt, absoluteDelta[1] / dt];
        }
      }
    }
  }, {
    key: "emit",
    value: function emit() {
      var state = this.state;
      var shared = this.shared;
      var config = this.config;
      if (!state._active) this.clean();
      if ((state._blocked || !state.intentional) && !state._force && !config.triggerAllEvents) return;
      var memo = this.handler(_objectSpread2(_objectSpread2(_objectSpread2({}, shared), state), {}, _rollupPluginBabelHelpers.defineProperty({}, this.aliasKey, state.values)));
      if (memo !== undefined) state.memo = memo;
    }
  }, {
    key: "clean",
    value: function clean() {
      this.eventStore.clean();
      this.timeoutStore.clean();
    }
  }]);

  return Engine;
}();

function selectAxis(_ref3, threshold) {
  var _ref4 = _rollupPluginBabelHelpers.slicedToArray(_ref3, 2),
      dx = _ref4[0],
      dy = _ref4[1];

  var absDx = Math.abs(dx);
  var absDy = Math.abs(dy);

  if (absDx > absDy && absDx > threshold) {
    return 'x';
  }

  if (absDy > absDx && absDy > threshold) {
    return 'y';
  }

  return undefined;
}

var CoordinatesEngine = /*#__PURE__*/function (_Engine) {
  _rollupPluginBabelHelpers.inherits(CoordinatesEngine, _Engine);

  var _super = _rollupPluginBabelHelpers.createSuper(CoordinatesEngine);

  function CoordinatesEngine() {
    var _this;

    _rollupPluginBabelHelpers.classCallCheck(this, CoordinatesEngine);

    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty(_rollupPluginBabelHelpers.assertThisInitialized(_this), "aliasKey", 'xy');

    return _this;
  }

  _rollupPluginBabelHelpers.createClass(CoordinatesEngine, [{
    key: "reset",
    value: function reset() {
      _rollupPluginBabelHelpers.get(_rollupPluginBabelHelpers.getPrototypeOf(CoordinatesEngine.prototype), "reset", this).call(this);

      this.state.axis = undefined;
    }
  }, {
    key: "init",
    value: function init() {
      this.state.offset = [0, 0];
      this.state.lastOffset = [0, 0];
    }
  }, {
    key: "computeOffset",
    value: function computeOffset() {
      this.state.offset = mathsB2a210f4_esm.V.add(this.state.lastOffset, this.state.movement);
    }
  }, {
    key: "computeMovement",
    value: function computeMovement() {
      this.state.movement = mathsB2a210f4_esm.V.sub(this.state.offset, this.state.lastOffset);
    }
  }, {
    key: "axisIntent",
    value: function axisIntent(event) {
      var state = this.state;
      var config = this.config;

      if (!state.axis && event) {
        var threshold = _rollupPluginBabelHelpers["typeof"](config.axisThreshold) === 'object' ? config.axisThreshold[getPointerType(event)] : config.axisThreshold;
        state.axis = selectAxis(state._movement, threshold);
      }

      state._blocked = (config.lockDirection || !!config.axis) && !state.axis || !!config.axis && config.axis !== state.axis;
    }
  }, {
    key: "restrictToAxis",
    value: function restrictToAxis(v) {
      if (this.config.axis || this.config.lockDirection) {
        switch (this.state.axis) {
          case 'x':
            v[1] = 0;
            break;

          case 'y':
            v[0] = 0;
            break;
        }
      }
    }
  }]);

  return CoordinatesEngine;
}(Engine);

var identity = function identity(v) {
  return v;
};

var DEFAULT_RUBBERBAND = 0.15;
var commonConfigResolver = {
  enabled: function enabled() {
    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
    return value;
  },
  eventOptions: function eventOptions(value, _k, config) {
    return _objectSpread2(_objectSpread2({}, config.shared.eventOptions), value);
  },
  preventDefault: function preventDefault() {
    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    return value;
  },
  triggerAllEvents: function triggerAllEvents() {
    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    return value;
  },
  rubberband: function rubberband() {
    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

    switch (value) {
      case true:
        return [DEFAULT_RUBBERBAND, DEFAULT_RUBBERBAND];

      case false:
        return [0, 0];

      default:
        return mathsB2a210f4_esm.V.toVector(value);
    }
  },
  from: function from(value) {
    if (typeof value === 'function') return value;
    if (value != null) return mathsB2a210f4_esm.V.toVector(value);
  },
  transform: function transform(value, _k, config) {
    var transform = value || config.shared.transform;
    this.hasCustomTransform = !!transform;

    if (process.env.NODE_ENV === 'development') {
      var originalTransform = transform || identity;
      return function (v) {
        var r = originalTransform(v);

        if (!isFinite(r[0]) || !isFinite(r[1])) {
          console.warn("[@use-gesture]: config.transform() must produce a valid result, but it was: [".concat(r[0], ",").concat([1], "]"));
        }

        return r;
      };
    }

    return transform || identity;
  },
  threshold: function threshold(value) {
    return mathsB2a210f4_esm.V.toVector(value, 0);
  }
};

if (process.env.NODE_ENV === 'development') {
  Object.assign(commonConfigResolver, {
    domTarget: function domTarget(value) {
      if (value !== undefined) {
        throw Error("[@use-gesture]: `domTarget` option has been renamed to `target`.");
      }

      return NaN;
    },
    lockDirection: function lockDirection(value) {
      if (value !== undefined) {
        throw Error("[@use-gesture]: `lockDirection` option has been merged with `axis`. Use it as in `{ axis: 'lock' }`");
      }

      return NaN;
    },
    initial: function initial(value) {
      if (value !== undefined) {
        throw Error("[@use-gesture]: `initial` option has been renamed to `from`.");
      }

      return NaN;
    }
  });
}

var DEFAULT_AXIS_THRESHOLD = 0;

var coordinatesConfigResolver = _objectSpread2(_objectSpread2({}, commonConfigResolver), {}, {
  axis: function axis(_v, _k, _ref5) {
    var axis = _ref5.axis;
    this.lockDirection = axis === 'lock';
    if (!this.lockDirection) return axis;
  },
  axisThreshold: function axisThreshold() {
    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_AXIS_THRESHOLD;
    return value;
  },
  bounds: function bounds() {
    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    if (typeof value === 'function') {
      return function (state) {
        return coordinatesConfigResolver.bounds(value(state));
      };
    }

    if ('current' in value) {
      return function () {
        return value.current;
      };
    }

    if (typeof HTMLElement === 'function' && value instanceof HTMLElement) {
      return value;
    }

    var _value$left = value.left,
        left = _value$left === void 0 ? -Infinity : _value$left,
        _value$right = value.right,
        right = _value$right === void 0 ? Infinity : _value$right,
        _value$top = value.top,
        top = _value$top === void 0 ? -Infinity : _value$top,
        _value$bottom = value.bottom,
        bottom = _value$bottom === void 0 ? Infinity : _value$bottom;
    return [[left, right], [top, bottom]];
  }
});

var DISPLACEMENT = 10;
var KEYS_DELTA_MAP = {
  ArrowRight: function ArrowRight() {
    var factor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    return [DISPLACEMENT * factor, 0];
  },
  ArrowLeft: function ArrowLeft() {
    var factor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    return [-DISPLACEMENT * factor, 0];
  },
  ArrowUp: function ArrowUp() {
    var factor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    return [0, -DISPLACEMENT * factor];
  },
  ArrowDown: function ArrowDown() {
    var factor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    return [0, DISPLACEMENT * factor];
  }
};

var DragEngine = /*#__PURE__*/function (_CoordinatesEngine) {
  _rollupPluginBabelHelpers.inherits(DragEngine, _CoordinatesEngine);

  var _super2 = _rollupPluginBabelHelpers.createSuper(DragEngine);

  function DragEngine() {
    var _this2;

    _rollupPluginBabelHelpers.classCallCheck(this, DragEngine);

    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }

    _this2 = _super2.call.apply(_super2, [this].concat(args));

    _defineProperty(_rollupPluginBabelHelpers.assertThisInitialized(_this2), "ingKey", 'dragging');

    return _this2;
  }

  _rollupPluginBabelHelpers.createClass(DragEngine, [{
    key: "reset",
    value: function reset() {
      _rollupPluginBabelHelpers.get(_rollupPluginBabelHelpers.getPrototypeOf(DragEngine.prototype), "reset", this).call(this);

      var state = this.state;
      state._pointerId = undefined;
      state._pointerActive = false;
      state._keyboardActive = false;
      state._preventScroll = false;
      state._delayed = false;
      state.swipe = [0, 0];
      state.tap = false;
      state.canceled = false;
      state.cancel = this.cancel.bind(this);
    }
  }, {
    key: "setup",
    value: function setup() {
      var state = this.state;

      if (state._bounds instanceof HTMLElement) {
        var boundRect = state._bounds.getBoundingClientRect();

        var targetRect = state.currentTarget.getBoundingClientRect();
        var _bounds = {
          left: boundRect.left - targetRect.left + state.offset[0],
          right: boundRect.right - targetRect.right + state.offset[0],
          top: boundRect.top - targetRect.top + state.offset[1],
          bottom: boundRect.bottom - targetRect.bottom + state.offset[1]
        };
        state._bounds = coordinatesConfigResolver.bounds(_bounds);
      }
    }
  }, {
    key: "cancel",
    value: function cancel() {
      var _this3 = this;

      var state = this.state;
      if (state.canceled) return;
      state.canceled = true;
      state._active = false;
      setTimeout(function () {
        _this3.compute();

        _this3.emit();
      }, 0);
    }
  }, {
    key: "setActive",
    value: function setActive() {
      this.state._active = this.state._pointerActive || this.state._keyboardActive;
    }
  }, {
    key: "clean",
    value: function clean() {
      this.pointerClean();
      this.state._pointerActive = false;
      this.state._keyboardActive = false;

      _rollupPluginBabelHelpers.get(_rollupPluginBabelHelpers.getPrototypeOf(DragEngine.prototype), "clean", this).call(this);
    }
  }, {
    key: "pointerDown",
    value: function pointerDown(event) {
      var config = this.config;
      var state = this.state;
      if (event.buttons != null && (Array.isArray(config.pointerButtons) ? !config.pointerButtons.includes(event.buttons) : config.pointerButtons !== -1 && config.pointerButtons !== event.buttons)) return;
      var ctrlIds = this.ctrl.setEventIds(event);

      if (config.pointerCapture) {
        event.target.setPointerCapture(event.pointerId);
      }

      if (ctrlIds && ctrlIds.size > 1 && state._pointerActive) return;
      this.start(event);
      this.setupPointer(event);
      state._pointerId = pointerId(event);
      state._pointerActive = true;
      this.computeValues(pointerValues(event));
      this.computeInitial();

      if (config.preventScrollAxis && getPointerType(event) !== 'mouse') {
        state._active = false;
        this.setupScrollPrevention(event);
      } else if (config.delay > 0) {
        this.setupDelayTrigger(event);

        if (config.triggerAllEvents) {
          this.compute(event);
          this.emit();
        }
      } else {
        this.startPointerDrag(event);
      }
    }
  }, {
    key: "startPointerDrag",
    value: function startPointerDrag(event) {
      var state = this.state;
      state._active = true;
      state._preventScroll = true;
      state._delayed = false;
      this.compute(event);
      this.emit();
    }
  }, {
    key: "pointerMove",
    value: function pointerMove(event) {
      var state = this.state;
      var config = this.config;
      if (!state._pointerActive) return;
      if (state.type === event.type && event.timeStamp === state.timeStamp) return;
      var id = pointerId(event);
      if (state._pointerId !== undefined && id !== state._pointerId) return;

      var _values = pointerValues(event);

      if (document.pointerLockElement === event.target) {
        state._delta = [event.movementX, event.movementY];
      } else {
        state._delta = mathsB2a210f4_esm.V.sub(_values, state._values);
        this.computeValues(_values);
      }

      mathsB2a210f4_esm.V.addTo(state._movement, state._delta);
      this.compute(event);

      if (state._delayed && state.intentional) {
        this.timeoutStore.remove('dragDelay');
        state.active = false;
        this.startPointerDrag(event);
        return;
      }

      if (config.preventScrollAxis && !state._preventScroll) {
        if (state.axis) {
          if (state.axis === config.preventScrollAxis || config.preventScrollAxis === 'xy') {
            state._active = false;
            this.clean();
            return;
          } else {
            this.timeoutStore.remove('startPointerDrag');
            this.startPointerDrag(event);
            return;
          }
        } else {
          return;
        }
      }

      this.emit();
    }
  }, {
    key: "pointerUp",
    value: function pointerUp(event) {
      this.ctrl.setEventIds(event);

      try {
        if (this.config.pointerCapture && event.target.hasPointerCapture(event.pointerId)) {
          ;
          event.target.releasePointerCapture(event.pointerId);
        }
      } catch (_unused) {
        if (process.env.NODE_ENV === 'development') {
          console.warn("[@use-gesture]: If you see this message, it's likely that you're using an outdated version of `@react-three/fiber`. \n\nPlease upgrade to the latest version.");
        }
      }

      var state = this.state;
      var config = this.config;
      if (!state._active || !state._pointerActive) return;
      var id = pointerId(event);
      if (state._pointerId !== undefined && id !== state._pointerId) return;
      this.state._pointerActive = false;
      this.setActive();
      this.compute(event);

      var _state$_distance = _rollupPluginBabelHelpers.slicedToArray(state._distance, 2),
          dx = _state$_distance[0],
          dy = _state$_distance[1];

      state.tap = dx <= config.tapsThreshold && dy <= config.tapsThreshold;

      if (state.tap && config.filterTaps) {
        state._force = true;
      } else {
        var _state$direction = _rollupPluginBabelHelpers.slicedToArray(state.direction, 2),
            dirx = _state$direction[0],
            diry = _state$direction[1];

        var _state$velocity = _rollupPluginBabelHelpers.slicedToArray(state.velocity, 2),
            vx = _state$velocity[0],
            vy = _state$velocity[1];

        var _state$movement = _rollupPluginBabelHelpers.slicedToArray(state.movement, 2),
            mx = _state$movement[0],
            my = _state$movement[1];

        var _config$swipe$velocit = _rollupPluginBabelHelpers.slicedToArray(config.swipe.velocity, 2),
            svx = _config$swipe$velocit[0],
            svy = _config$swipe$velocit[1];

        var _config$swipe$distanc = _rollupPluginBabelHelpers.slicedToArray(config.swipe.distance, 2),
            sx = _config$swipe$distanc[0],
            sy = _config$swipe$distanc[1];

        var sdt = config.swipe.duration;

        if (state.elapsedTime < sdt) {
          if (Math.abs(vx) > svx && Math.abs(mx) > sx) state.swipe[0] = dirx;
          if (Math.abs(vy) > svy && Math.abs(my) > sy) state.swipe[1] = diry;
        }
      }

      this.emit();
    }
  }, {
    key: "pointerClick",
    value: function pointerClick(event) {
      if (!this.state.tap) {
        event.preventDefault();
        event.stopPropagation();
      }
    }
  }, {
    key: "setupPointer",
    value: function setupPointer(event) {
      var config = this.config;
      var device = config.device;

      if (process.env.NODE_ENV === 'development') {
        try {
          if (device === 'pointer' && config.preventScrollDelay === undefined) {
            var currentTarget = 'uv' in event ? event.sourceEvent.currentTarget : event.currentTarget;
            var style = window.getComputedStyle(currentTarget);

            if (style.touchAction === 'auto') {
              console.warn("[@use-gesture]: The drag target has its `touch-action` style property set to `auto`. It is recommended to add `touch-action: 'none'` so that the drag gesture behaves correctly on touch-enabled devices. For more information read this: https://use-gesture.netlify.app/docs/extras/#touch-action.\n\nThis message will only show in development mode. It won't appear in production. If this is intended, you can ignore it.", currentTarget);
            }
          }
        } catch (_unused2) {}
      }

      if (config.pointerLock) {
        event.currentTarget.requestPointerLock();
      }

      if (!config.pointerCapture) {
        this.eventStore.add(this.sharedConfig.window, device, 'change', this.pointerMove.bind(this));
        this.eventStore.add(this.sharedConfig.window, device, 'end', this.pointerUp.bind(this));
        this.eventStore.add(this.sharedConfig.window, device, 'cancel', this.pointerUp.bind(this));
      }
    }
  }, {
    key: "pointerClean",
    value: function pointerClean() {
      if (this.config.pointerLock && document.pointerLockElement === this.state.currentTarget) {
        document.exitPointerLock();
      }
    }
  }, {
    key: "preventScroll",
    value: function preventScroll(event) {
      if (this.state._preventScroll && event.cancelable) {
        event.preventDefault();
      }
    }
  }, {
    key: "setupScrollPrevention",
    value: function setupScrollPrevention(event) {
      this.state._preventScroll = false;
      persistEvent(event);
      var remove = this.eventStore.add(this.sharedConfig.window, 'touch', 'change', this.preventScroll.bind(this), {
        passive: false
      });
      this.eventStore.add(this.sharedConfig.window, 'touch', 'end', remove);
      this.eventStore.add(this.sharedConfig.window, 'touch', 'cancel', remove);
      this.timeoutStore.add('startPointerDrag', this.startPointerDrag.bind(this), this.config.preventScrollDelay, event);
    }
  }, {
    key: "setupDelayTrigger",
    value: function setupDelayTrigger(event) {
      var _this4 = this;

      this.state._delayed = true;
      this.timeoutStore.add('dragDelay', function () {
        _this4.state._step = [0, 0];

        _this4.startPointerDrag(event);
      }, this.config.delay);
    }
  }, {
    key: "keyDown",
    value: function keyDown(event) {
      var deltaFn = KEYS_DELTA_MAP[event.key];

      if (deltaFn) {
        var state = this.state;
        var factor = event.shiftKey ? 10 : event.altKey ? 0.1 : 1;
        this.start(event);
        state._delta = deltaFn(factor);
        state._keyboardActive = true;
        mathsB2a210f4_esm.V.addTo(state._movement, state._delta);
        this.compute(event);
        this.emit();
      }
    }
  }, {
    key: "keyUp",
    value: function keyUp(event) {
      if (!(event.key in KEYS_DELTA_MAP)) return;
      this.state._keyboardActive = false;
      this.setActive();
      this.compute(event);
      this.emit();
    }
  }, {
    key: "bind",
    value: function bind(bindFunction) {
      var device = this.config.device;
      bindFunction(device, 'start', this.pointerDown.bind(this));

      if (this.config.pointerCapture) {
        bindFunction(device, 'change', this.pointerMove.bind(this));
        bindFunction(device, 'end', this.pointerUp.bind(this));
        bindFunction(device, 'cancel', this.pointerUp.bind(this));
        bindFunction('lostPointerCapture', '', this.pointerUp.bind(this));
      }

      bindFunction('key', 'down', this.keyDown.bind(this));
      bindFunction('key', 'up', this.keyUp.bind(this));

      if (this.config.filterTaps) {
        bindFunction('click', '', this.pointerClick.bind(this), {
          capture: true,
          passive: false
        });
      }
    }
  }]);

  return DragEngine;
}(CoordinatesEngine);

function persistEvent(event) {
  'persist' in event && typeof event.persist === 'function' && event.persist();
}

var isBrowser = typeof window !== 'undefined' && window.document && window.document.createElement;

function supportsTouchEvents() {
  return isBrowser && 'ontouchstart' in window;
}

function isTouchScreen() {
  return supportsTouchEvents() || isBrowser && window.navigator.maxTouchPoints > 1;
}

function supportsPointerEvents() {
  return isBrowser && 'onpointerdown' in window;
}

function supportsPointerLock() {
  return isBrowser && 'exitPointerLock' in window.document;
}

function supportsGestureEvents() {
  try {
    return 'constructor' in GestureEvent;
  } catch (e) {
    return false;
  }
}

var SUPPORT = {
  isBrowser: isBrowser,
  gesture: supportsGestureEvents(),
  touch: isTouchScreen(),
  touchscreen: isTouchScreen(),
  pointer: supportsPointerEvents(),
  pointerLock: supportsPointerLock()
};
var DEFAULT_PREVENT_SCROLL_DELAY = 250;
var DEFAULT_DRAG_DELAY = 180;
var DEFAULT_SWIPE_VELOCITY = 0.5;
var DEFAULT_SWIPE_DISTANCE = 50;
var DEFAULT_SWIPE_DURATION = 250;
var DEFAULT_DRAG_AXIS_THRESHOLD = {
  mouse: 0,
  touch: 0,
  pen: 8
};

var dragConfigResolver = _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {
  device: function device(_v, _k, _ref6) {
    var _ref6$pointer = _ref6.pointer;
    _ref6$pointer = _ref6$pointer === void 0 ? {} : _ref6$pointer;
    var _ref6$pointer$touch = _ref6$pointer.touch,
        touch = _ref6$pointer$touch === void 0 ? false : _ref6$pointer$touch,
        _ref6$pointer$lock = _ref6$pointer.lock,
        lock = _ref6$pointer$lock === void 0 ? false : _ref6$pointer$lock,
        _ref6$pointer$mouse = _ref6$pointer.mouse,
        mouse = _ref6$pointer$mouse === void 0 ? false : _ref6$pointer$mouse;
    this.pointerLock = lock && SUPPORT.pointerLock;
    if (SUPPORT.touch && touch) return 'touch';
    if (this.pointerLock) return 'mouse';
    if (SUPPORT.pointer && !mouse) return 'pointer';
    if (SUPPORT.touch) return 'touch';
    return 'mouse';
  },
  preventScrollAxis: function preventScrollAxis(value, _k, _ref7) {
    var preventScroll = _ref7.preventScroll;
    this.preventScrollDelay = typeof preventScroll === 'number' ? preventScroll : preventScroll || preventScroll === undefined && value ? DEFAULT_PREVENT_SCROLL_DELAY : undefined;
    if (!SUPPORT.touchscreen || preventScroll === false) return undefined;
    return value ? value : preventScroll !== undefined ? 'y' : undefined;
  },
  pointerCapture: function pointerCapture(_v, _k, _ref8) {
    var _ref8$pointer = _ref8.pointer;
    _ref8$pointer = _ref8$pointer === void 0 ? {} : _ref8$pointer;
    var _ref8$pointer$capture = _ref8$pointer.capture,
        capture = _ref8$pointer$capture === void 0 ? true : _ref8$pointer$capture,
        _ref8$pointer$buttons = _ref8$pointer.buttons,
        buttons = _ref8$pointer$buttons === void 0 ? 1 : _ref8$pointer$buttons;
    this.pointerButtons = buttons;
    return !this.pointerLock && this.device === 'pointer' && capture;
  },
  threshold: function threshold(value, _k, _ref9) {
    var _ref9$filterTaps = _ref9.filterTaps,
        filterTaps = _ref9$filterTaps === void 0 ? false : _ref9$filterTaps,
        _ref9$tapsThreshold = _ref9.tapsThreshold,
        tapsThreshold = _ref9$tapsThreshold === void 0 ? 3 : _ref9$tapsThreshold,
        _ref9$axis = _ref9.axis,
        axis = _ref9$axis === void 0 ? undefined : _ref9$axis;
    var threshold = mathsB2a210f4_esm.V.toVector(value, filterTaps ? tapsThreshold : axis ? 1 : 0);
    this.filterTaps = filterTaps;
    this.tapsThreshold = tapsThreshold;
    return threshold;
  },
  swipe: function swipe() {
    var _ref10 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref10$velocity = _ref10.velocity,
        velocity = _ref10$velocity === void 0 ? DEFAULT_SWIPE_VELOCITY : _ref10$velocity,
        _ref10$distance = _ref10.distance,
        distance = _ref10$distance === void 0 ? DEFAULT_SWIPE_DISTANCE : _ref10$distance,
        _ref10$duration = _ref10.duration,
        duration = _ref10$duration === void 0 ? DEFAULT_SWIPE_DURATION : _ref10$duration;

    return {
      velocity: this.transform(mathsB2a210f4_esm.V.toVector(velocity)),
      distance: this.transform(mathsB2a210f4_esm.V.toVector(distance)),
      duration: duration
    };
  },
  delay: function delay() {
    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

    switch (value) {
      case true:
        return DEFAULT_DRAG_DELAY;

      case false:
        return 0;

      default:
        return value;
    }
  },
  axisThreshold: function axisThreshold(value) {
    if (!value) return DEFAULT_DRAG_AXIS_THRESHOLD;
    return _objectSpread2(_objectSpread2({}, DEFAULT_DRAG_AXIS_THRESHOLD), value);
  }
});

if (process.env.NODE_ENV === 'development') {
  Object.assign(dragConfigResolver, {
    useTouch: function useTouch(value) {
      if (value !== undefined) {
        throw Error("[@use-gesture]: `useTouch` option has been renamed to `pointer.touch`. Use it as in `{ pointer: { touch: true } }`.");
      }

      return NaN;
    },
    experimental_preventWindowScrollY: function experimental_preventWindowScrollY(value) {
      if (value !== undefined) {
        throw Error("[@use-gesture]: `experimental_preventWindowScrollY` option has been renamed to `preventScroll`.");
      }

      return NaN;
    },
    swipeVelocity: function swipeVelocity(value) {
      if (value !== undefined) {
        throw Error("[@use-gesture]: `swipeVelocity` option has been renamed to `swipe.velocity`. Use it as in `{ swipe: { velocity: 0.5 } }`.");
      }

      return NaN;
    },
    swipeDistance: function swipeDistance(value) {
      if (value !== undefined) {
        throw Error("[@use-gesture]: `swipeDistance` option has been renamed to `swipe.distance`. Use it as in `{ swipe: { distance: 50 } }`.");
      }

      return NaN;
    },
    swipeDuration: function swipeDuration(value) {
      if (value !== undefined) {
        throw Error("[@use-gesture]: `swipeDuration` option has been renamed to `swipe.duration`. Use it as in `{ swipe: { duration: 250 } }`.");
      }

      return NaN;
    }
  });
}

_objectSpread2(_objectSpread2({}, commonConfigResolver), {}, {
  device: function device(_v, _k, _ref11) {
    var shared = _ref11.shared,
        _ref11$pointer = _ref11.pointer;
    _ref11$pointer = _ref11$pointer === void 0 ? {} : _ref11$pointer;
    var _ref11$pointer$touch = _ref11$pointer.touch,
        touch = _ref11$pointer$touch === void 0 ? false : _ref11$pointer$touch;
    var sharedConfig = shared;
    if (sharedConfig.target && !SUPPORT.touch && SUPPORT.gesture) return 'gesture';
    if (SUPPORT.touch && touch) return 'touch';

    if (SUPPORT.touchscreen) {
      if (SUPPORT.pointer) return 'pointer';
      if (SUPPORT.touch) return 'touch';
    }
  },
  bounds: function bounds(_v, _k, _ref12) {
    var _ref12$scaleBounds = _ref12.scaleBounds,
        scaleBounds = _ref12$scaleBounds === void 0 ? {} : _ref12$scaleBounds,
        _ref12$angleBounds = _ref12.angleBounds,
        angleBounds = _ref12$angleBounds === void 0 ? {} : _ref12$angleBounds;

    var _scaleBounds = function _scaleBounds(state) {
      var D = assignDefault(call(scaleBounds, state), {
        min: -Infinity,
        max: Infinity
      });
      return [D.min, D.max];
    };

    var _angleBounds = function _angleBounds(state) {
      var A = assignDefault(call(angleBounds, state), {
        min: -Infinity,
        max: Infinity
      });
      return [A.min, A.max];
    };

    if (typeof scaleBounds !== 'function' && typeof angleBounds !== 'function') return [_scaleBounds(), _angleBounds()];
    return function (state) {
      return [_scaleBounds(state), _angleBounds(state)];
    };
  },
  threshold: function threshold(value, _k, config) {
    this.lockDirection = config.axis === 'lock';
    var threshold = mathsB2a210f4_esm.V.toVector(value, this.lockDirection ? [0.1, 3] : 0);
    return threshold;
  },
  modifierKey: function modifierKey(value) {
    if (value === undefined) return 'ctrlKey';
    return value;
  }
});

_objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {
  mouseOnly: function mouseOnly() {
    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
    return value;
  }
});

_objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {
  mouseOnly: function mouseOnly() {
    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
    return value;
  }
});

var EngineMap = new Map();
var ConfigResolverMap = new Map();

function registerAction(action) {
  EngineMap.set(action.key, action.engine);
  ConfigResolverMap.set(action.key, action.resolver);
}

var dragAction = {
  key: 'drag',
  engine: DragEngine,
  resolver: dragConfigResolver
};

exports.C = ConfigResolverMap;
exports.E = EngineMap;
exports.S = SUPPORT;
exports._ = _objectSpread2;
exports.a = _defineProperty;
exports.b = touchIds;
exports.c = chain;
exports.d = toHandlerProp;
exports.e = dragAction;
exports.i = isTouch;
exports.p = parseProp;
exports.r = registerAction;
exports.t = toDomEventType;
//# sourceMappingURL=actions-1416bf77.esm.js.map
