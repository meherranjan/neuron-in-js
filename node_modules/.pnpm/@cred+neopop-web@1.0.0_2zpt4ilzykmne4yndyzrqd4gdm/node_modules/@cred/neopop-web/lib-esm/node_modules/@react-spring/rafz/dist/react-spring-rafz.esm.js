import { toConsumableArray as _toConsumableArray } from '../../../../_virtual/_rollupPluginBabelHelpers.js';

var updateQueue = makeQueue();

var raf = function raf(fn) {
  return schedule(fn, updateQueue);
};

var writeQueue = makeQueue();

raf.write = function (fn) {
  return schedule(fn, writeQueue);
};

var onStartQueue = makeQueue();

raf.onStart = function (fn) {
  return schedule(fn, onStartQueue);
};

var onFrameQueue = makeQueue();

raf.onFrame = function (fn) {
  return schedule(fn, onFrameQueue);
};

var onFinishQueue = makeQueue();

raf.onFinish = function (fn) {
  return schedule(fn, onFinishQueue);
};

var timeouts = [];

raf.setTimeout = function (handler, ms) {
  var time = raf.now() + ms;

  var cancel = function cancel() {
    var i = timeouts.findIndex(function (t) {
      return t.cancel == cancel;
    });
    if (~i) timeouts.splice(i, 1);
    pendingCount -= ~i ? 1 : 0;
  };

  var timeout = {
    time: time,
    handler: handler,
    cancel: cancel
  };
  timeouts.splice(findTimeout(time), 0, timeout);
  pendingCount += 1;
  start();
  return timeout;
};

var findTimeout = function findTimeout(time) {
  return ~(~timeouts.findIndex(function (t) {
    return t.time > time;
  }) || ~timeouts.length);
};

raf.cancel = function (fn) {
  onStartQueue["delete"](fn);
  onFrameQueue["delete"](fn);
  updateQueue["delete"](fn);
  writeQueue["delete"](fn);
  onFinishQueue["delete"](fn);
};

raf.sync = function (fn) {
  sync = true;
  raf.batchedUpdates(fn);
  sync = false;
};

raf.throttle = function (fn) {
  var lastArgs;

  function queuedFn() {
    try {
      fn.apply(void 0, _toConsumableArray(lastArgs));
    } finally {
      lastArgs = null;
    }
  }

  function throttled() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    lastArgs = args;
    raf.onStart(queuedFn);
  }

  throttled.handler = fn;

  throttled.cancel = function () {
    onStartQueue["delete"](queuedFn);
    lastArgs = null;
  };

  return throttled;
};

var nativeRaf = typeof window != 'undefined' ? window.requestAnimationFrame : function () {};

raf.use = function (impl) {
  return nativeRaf = impl;
};

raf.now = typeof performance != 'undefined' ? function () {
  return performance.now();
} : Date.now;

raf.batchedUpdates = function (fn) {
  return fn();
};

raf["catch"] = console.error;
raf.frameLoop = 'always';

raf.advance = function () {
  if (raf.frameLoop !== 'demand') {
    console.warn('Cannot call the manual advancement of rafz whilst frameLoop is not set as demand');
  } else {
    update();
  }
};

var ts = -1;
var pendingCount = 0;
var sync = false;

function schedule(fn, queue) {
  if (sync) {
    queue["delete"](fn);
    fn(0);
  } else {
    queue.add(fn);
    start();
  }
}

function start() {
  if (ts < 0) {
    ts = 0;

    if (raf.frameLoop !== 'demand') {
      nativeRaf(loop);
    }
  }
}

function stop() {
  ts = -1;
}

function loop() {
  if (~ts) {
    nativeRaf(loop);
    raf.batchedUpdates(update);
  }
}

function update() {
  var prevTs = ts;
  ts = raf.now();
  var count = findTimeout(ts);

  if (count) {
    eachSafely(timeouts.splice(0, count), function (t) {
      return t.handler();
    });
    pendingCount -= count;
  }

  onStartQueue.flush();
  updateQueue.flush(prevTs ? Math.min(64, ts - prevTs) : 16.667);
  onFrameQueue.flush();
  writeQueue.flush();
  onFinishQueue.flush();

  if (!pendingCount) {
    stop();
  }
}

function makeQueue() {
  var next = new Set();
  var current = next;
  return {
    add: function add(fn) {
      pendingCount += current == next && !next.has(fn) ? 1 : 0;
      next.add(fn);
    },
    "delete": function _delete(fn) {
      pendingCount -= current == next && next.has(fn) ? 1 : 0;
      return next["delete"](fn);
    },
    flush: function flush(arg) {
      if (current.size) {
        next = new Set();
        pendingCount -= current.size;
        eachSafely(current, function (fn) {
          return fn(arg) && next.add(fn);
        });
        pendingCount += next.size;
        current = next;
      }
    }
  };
}

function eachSafely(values, each) {
  values.forEach(function (value) {
    try {
      each(value);
    } catch (e) {
      raf["catch"](e);
    }
  });
}

export { raf };
//# sourceMappingURL=react-spring-rafz.esm.js.map
